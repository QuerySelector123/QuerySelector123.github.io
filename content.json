{"meta":{"title":"QuerySelector","subtitle":null,"description":"好少年光芒万丈","author":"QuerySelector","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-09-17T09:09:34.613Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のQuerySelector] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"第一篇","slug":"第一篇","date":"2021-09-10T04:48:28.000Z","updated":"2021-09-17T09:09:33.882Z","comments":true,"path":"2021/09/10/第一篇/","link":"","permalink":"/2021/09/10/第一篇/","excerpt":"","text":"这是标题","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-09-09T16:15:57.237Z","updated":"2021-09-09T16:15:57.238Z","comments":true,"path":"2021/09/10/hello-world/","link":"","permalink":"/2021/09/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"js继承","slug":"js继承","date":"2020-06-11T09:04:40.000Z","updated":"2020-06-21T13:10:21.276Z","comments":true,"path":"2020/06/11/js继承/","link":"","permalink":"/2020/06/11/js继承/","excerpt":"","text":"js继承1.概念​ 通过一种方式让一个对象访问到另一个对象中的属性和方法，我们把这种方式称之为继承。 2.继承的几种方式1.原型继承​ 原理： ​ 将原对象的实例对象一个对象的prototype,继承的属性和方法，会存在新对象的_proto_中，而新对象自己 ​ 的属性还是会在第一层。 function Animal (name, type, age) { this.name = name this.type = type this.age = age } var animal = new Animal(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) // console.log(animal) function Dog (nick) { this.nick = nick this.CatchMouse = function () { console.log(&quot;我会抓老鼠&quot;) } } Dog.prototype = animal var dog1 = new Dog(&quot;笑哈哈&quot;) console.log(dog1) // Cat {nick: &quot;笑哈哈&quot;, CatchMouse: ƒ} // CatchMouse: ƒ () // nick: &quot;笑哈哈&quot; // __proto__: Animal // age: &quot;飞哥&quot; // name: &quot;藏獒&quot; // type: &quot;蓝色&quot; // __proto__: Object 2.借用构造函数继承​ 原理： ​ 在新对象使用call方法传参，且改变this的指向，这样原对象中的参数属性和方法会绑定给新对象，且不是在_proto_中而是在对象的第一层。 function Animal (name, type, age) { this.name = name this.type = type this.age = age } // var animal = new Animal(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) // console.log(animal) function Dog (name, type, age) { Animal.call(this, name, type, age) this.CatchMouse = function () { console.log(&quot;我会抓老鼠&quot;) } } var dog1 = new Dog(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) console.log(dog1) // Dog {name: &quot;藏獒&quot;, type: &quot;蓝色&quot;, age: &quot;飞哥&quot;, CatchMouse: ƒ} // CatchMouse: ƒ () // age: &quot;飞哥&quot; // name: &quot;藏獒&quot; // type: &quot;蓝色&quot; // __proto__: Object 3.原型式继承​ 原理：其实和原型继承原理一样，只不过是将原型继承的逻辑写在了一个函数后返回值 function Animal (name, type, age) { this.name = name this.type = type this.age = age } var animal = new Animal(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) // console.log(animal) function Dog () { this.CatchMouse = function () { console.log(&quot;我会抓老鼠&quot;) } } function CreateObj (Sub, parent) { Sub.prototype = parent return new Sub() } // var dog1 = new Dog(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) var dog1 = CreateObj (Dog, animal) console.log(dog1) // Cat {nick: &quot;笑哈哈&quot;, CatchMouse: ƒ} // CatchMouse: ƒ () // nick: &quot;笑哈哈&quot; // __proto__: Animal // age: &quot;飞哥&quot; // name: &quot;藏獒&quot; // type: &quot;蓝色&quot; // __proto__: Object 4.组合继承","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"/tags/前端面试题/"}],"keywords":[]},{"title":"Vue中created和mounted的区别","slug":"Vue中created和mounted的区别","date":"2020-06-03T08:43:31.000Z","updated":"2020-06-21T13:10:21.258Z","comments":true,"path":"2020/06/03/Vue中created和mounted的区别/","link":"","permalink":"/2020/06/03/Vue中created和mounted的区别/","excerpt":"","text":"Vue中created和mounted的区别Created该函数在组件创建完成后被立即调用，在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。 但是还未渲染成HTML模板，组件中的data对象已经存在，可以对data进行操作了，即可以访问数据，发请求，ref依旧是undefined，挂载阶段还没开始，$el 属性目前尚不可用。 一般我们可以将对数据的初始化和初始化页面的请求放到里面，结束loading。 Mounted该函数是页面完成挂载之后执行的，这时 el 被新创建的 vm.$el 替换了，就可以操作 ref 了，一般会用于将组件初始时请求数据的方法放到这里面，filter 也是在这里生效。 如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。 可以拿到数据和节点，实例被挂载后调用。 注意 ：mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick： mounted: function () {this.$nextTick(function () {// Code that will run only after the// entire view has been rendered })} 该钩子在服务器端渲染期间不被调用。 区别从上面两个生命周期的定义看，最大的区别就是在到了mounted的时候\\$el会被替换了，我们就可以使用\\$ref来操作DOM了。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}],"keywords":[]},{"title":"MVC和MVVM","slug":"MVC和MVVM","date":"2020-06-02T01:30:20.000Z","updated":"2020-06-21T13:10:21.251Z","comments":true,"path":"2020/06/02/MVC和MVVM/","link":"","permalink":"/2020/06/02/MVC和MVVM/","excerpt":"","text":"MVC和MVVM详情：MVC：MVC开始是存在于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。比如一批统计数据可以分别用柱状图、饼图来表示。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。 模型－视图－控制器（MVC）是Xerox PARC在二十世纪八十年代为编程语言Smalltalk－80发明的一种软件设计模式，已被广泛使用。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。模型－视图－控制器模式是一个有用的工具箱，它有很多好处，但也有一些缺点。 MVVM：(优点)MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点 1. 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 2. 可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 3. 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。 4. 可测试：界面素来是比较难于测试的，测试可以针对ViewModel来写。 定义：MVC：​ MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 MVVM：​ MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。微软的WPF带来了新的技术体验，如Silverlight、音频、视频、3D、动画……，这导致了软件UI层更加细节化、可定制化。同时，在技术层面，WPF也带来了 诸如Binding、Dependency Property、Routed Events、Command、DataTemplate、ControlTemplate等新特性。MVVM（Model-View-ViewModel）框架的由来便是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。 区别：&gt;MVC的缺点： &gt; &gt;1.所有业务逻辑都在Controller里操作，逻辑复杂且不利于维护， &gt;2.大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 &gt;3.当 Model 频繁发生变化，需要主动更新到View ；当用户的操作导致Model发生变化，同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 由于MVC模式的缺陷，所以衍生出来MVC的变种模式MVVM模式 MVVM的核心是提供了View 和 ViewModel的数据双向绑定，View 和 model之间并没有直接的联系，而是通过了ViewModel联系了起来，而且数据双向绑定将View 和 Model之间的同步工作自动化，不需要人为干涉，所以我们开发者只需要关注业务逻辑即可，所以像Vue，React这样的框架我们是不需要直接的去操作DOM的，其复杂的数据维护状态都交给了MVVM来统一管理。 框架和设计模式的区别MVC是一种设计模式。框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。 框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。 框架模式有哪些？ MVC、MTV、MVP、CBD、ORM等等；","categories":[],"tags":[{"name":"软件设计模式","slug":"软件设计模式","permalink":"/tags/软件设计模式/"}],"keywords":[]},{"title":"vue路由传参","slug":"vue路由传参","date":"2020-05-27T01:56:47.000Z","updated":"2020-06-21T13:10:21.300Z","comments":true,"path":"2020/05/27/vue路由传参/","link":"","permalink":"/2020/05/27/vue路由传参/","excerpt":"","text":"vue路由传参1.传过去的参数为一个对象 let VideoGx = { data(){ return { list:[ { id:202004280001, title:&#39;惊雷，赵日天爆出惊人秘密...&#39; }, { id:202004280002, title:&#39;今天天气情况啊啊 啊 &#39; }, { id:202004280003, title:&#39;撒的撒打算打算的撒是的撒的飒飒&#39; }, { id:202004280004, title:&#39;今日基金大涨，A股用户赚翻！！！&#39; } ] } }, template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;(v,k) in list&quot; :key=&quot;v.id&quot;&gt; &lt;div class=&quot;thumb&quot;&gt;{{v.id}}&lt;/div&gt; &lt;router-link :to=&quot;{path:&#39;/video/play/&#39;+v.id}&quot;&gt;{{v.title}}&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; ` } let routes = [ {//配置一个首页的路由 path: &quot;/home&quot;, component: Home }, { path: &quot;/video&quot;, component: Video, redirect:&quot;/video/gx&quot;,//配置默认显示的重定向路由 children: [//配置子路由 { path: &quot;/video/gx&quot;, component: VideoGx }, { path: &quot;/video/ty&quot;, component: VideoTy }, { path: &quot;/video/kj&quot;, component: VideoKj }, { path:&quot;/video/play/:id?&quot;, //1.设置接收的参数为id ,?就是正则中的可有可没有的作用，写了? 没有传id也能匹配到当前路由 component:VideoPlay } ] }, { path: &quot;/music&quot;, component: Music, redirect:&quot;/music/rap&quot;, children: [//配置子路由 { path: &quot;/music/gd&quot;, component: MusicGd, }, { path: &quot;/music/top&quot;, component: MusicTop }, { path: &quot;/music/rap&quot;, component: MusicRap } ] }, { // 会匹配以 `/user-` 开头的任意路径 path: &quot;/user-*&quot;, component: Home } , { path:&quot;/&quot;, redirect:&quot;/home&quot; }, {//配置任意匹配路由，404处理，一定要注意：在路由的最后添加（匹配顺序就是从上往下） path: &quot;*&quot;, component: ErrorPage } ]; // 在地址栏获取 2.参数有name和一个params对象（参数会消失） let VideoGx = { data(){ return { list:[ { id:202004280001, title:&#39;惊雷，赵日天爆出惊人秘密...&#39; }, { id:202004280002, title:&#39;今天天气情况啊啊 啊 &#39; }, { id:202004280003, title:&#39;撒的撒打算打算的撒是的撒的飒飒&#39; }, { id:202004280004, title:&#39;今日基金大涨，A股用户赚翻！！！&#39; } ] } }, template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;(v,k) in list&quot; :key=&quot;v.id&quot;&gt; &lt;div class=&quot;thumb&quot;&gt;{{v.id}}&lt;/div&gt; &lt;router-link :to=&quot;{name:&#39;video-play&#39;,params:{id:v.id,hh:[&#39;1124321&#39;,&#39;fffsff&#39;]}}&quot;&gt;{{v.title}}&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; ` } let routes = [ {//配置一个首页的路由 path: &quot;/home&quot;, component: Home }, { path: &quot;/video&quot;, component: Video, redirect:&quot;/video/gx&quot;,//配置默认显示的重定向路由 children: [//配置子路由 { path: &quot;/video/gx&quot;, component: VideoGx }, { path: &quot;/video/ty&quot;, component: VideoTy }, { path: &quot;/video/kj&quot;, component: VideoKj }, { path:&quot;/video/play&quot;, name:&#39;video-play&#39;, component:VideoPlay } ] }, { path: &quot;/music&quot;, component: Music, redirect:&quot;/music/rap&quot;, children: [//配置子路由 { path: &quot;/music/gd&quot;, component: MusicGd, }, { path: &quot;/music/top&quot;, component: MusicTop }, { path: &quot;/music/rap&quot;, component: MusicRap } ] }, { // 会匹配以 `/user-` 开头的任意路径 path: &quot;/user-*&quot;, component: Home } , { path:&quot;/&quot;, redirect:&quot;/home&quot; }, {//配置任意匹配路由，404处理，一定要注意：在路由的最后添加（匹配顺序就是从上往下） path: &quot;*&quot;, component: ErrorPage } ]; // 在地址栏看不到 3.参数有name和一个键名为query的对象（刷新页面参数不会消失） //添加视频的子路由页面组件 let VideoGx = { data(){ return { list:[ { id:202004280001, title:&#39;惊雷，赵日天爆出惊人秘密...&#39; }, { id:202004280002, title:&#39;今天天气情况啊啊 啊 &#39; }, { id:202004280003, title:&#39;撒的撒打算打算的撒是的撒的飒飒&#39; }, { id:202004280004, title:&#39;今日基金大涨，A股用户赚翻！！！&#39; } ] } }, template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;(v,k) in list&quot; :key=&quot;v.id&quot;&gt; &lt;div class=&quot;thumb&quot;&gt;{{v.id}}&lt;/div&gt; &lt;router-link :to=&quot;{name:&#39;video-play&#39;,query:{id:v.id,type:&#39;gx&#39;}}&quot;&gt;{{v.title}}&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; ` } let routes = [ {//配置一个首页的路由 path: &quot;/home&quot;, component: Home }, { path: &quot;/video&quot;, component: Video, redirect:&quot;/video/gx&quot;,//配置默认显示的重定向路由 children: [//配置子路由 { path: &quot;/video/gx&quot;, component: VideoGx }, { path: &quot;/video/ty&quot;, component: VideoTy }, { path: &quot;/video/kj&quot;, component: VideoKj }, { path:&quot;/video/play&quot;, name:&#39;video-play&#39;, component:VideoPlay } ] }, { path: &quot;/music&quot;, component: Music, redirect:&quot;/music/rap&quot;, children: [//配置子路由 { path: &quot;/music/gd&quot;, component: MusicGd, }, { path: &quot;/music/top&quot;, component: MusicTop }, { path: &quot;/music/rap&quot;, component: MusicRap } ] }, { // 会匹配以 `/user-` 开头的任意路径 path: &quot;/user-*&quot;, component: Home } , { path:&quot;/&quot;, redirect:&quot;/home&quot; }, {//配置任意匹配路由，404处理，一定要注意：在路由的最后添加（匹配顺序就是从上往下） path: &quot;*&quot;, component: ErrorPage } ]; // 参数不会显示在地址栏","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[]},{"title":"vue组件通信全揭秘_共7章","slug":"vue组件通信全揭秘-共7章-掘金社区","date":"2020-05-25T00:44:37.000Z","updated":"2020-06-21T13:10:21.295Z","comments":true,"path":"2020/05/25/vue组件通信全揭秘-共7章-掘金社区/","link":"","permalink":"/2020/05/25/vue组件通信全揭秘-共7章-掘金社区/","excerpt":"","text":"vue组件通信全揭秘(共7章)这文章在一年前已经写出来了。今天还是决定放出来供所有人学习。为什么我会写vue组件通信全揭秘，因为无论任何组件模式的框架。组件是核心，只有把组件写组件之间能理顺了。项目也就自然顺了。内容非常多，而且一年后我觉得组件的通信部分的没有任何变化。没有任何一点过时。希望对大家有帮助 第01课：给你一个不学 Vue 的理由什么是 VueVue 是尤雨溪一个人的项目，是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 Vue 通过 Api 来进行统一性的管理，可以让整个团队的代码都用统一的风格和方法标准去运作，而且对组件系统也有强大的支持，在封装组件时通过 Props 和 Event 两个标准性的原则去调用，可以让开发更加得心应手。 请给一个不学 Vue 的理由如果非要让我说一个不学 Vue 的理由，可能是它的写法太方便了……你也可能觉得它借鉴的太多，没有亮眼的地方，那我只能说同样实现的东西就是那么方便，简洁的教程和 Api 文档接入整个开发体系，相当符合中国市场的开发——业务变动大、版本要求上线快、需求改动频繁、学习成本低……相比之下，同样有着高效的功能，集成了组件系统和 Virtual DOM。 阅读这一系列课程你可以学到什么？掌握 Vue 主要就是正确理解教程和深入掌握 Api 的用法，不但要会用，更重要的是学会对症下药，在任何一种场景下使用最简洁、最正确、最合理的代码才是关键。只有对 Api 和教程有了一定程度的项目实战和组件库实战经验才能把它用的游刃有余。 在 Vue2.0 起步的时候我在掘金上进行了 Vue 课程的一系列套课的讲解，从基础到 Vuex，最后到组件库的实战都进行了简单的讲解。期间也经过大量的项目实战和组件库的实践，通过一步步总结，对 Api 文档的深入理解和测试性模拟，总结了一些真实场景的正确用法和常用案例需求，让你在开发中少走弯路，少刨坑。 除了 Vue 还能学到什么在 Vue 开发中，我们不但要准确的运用 Api，还要结合 es6 的新语法，用更深更强大的新特性来组织代码，这同样也是下一代 Javascript 的标准： let 和 const 命令 变量的解构赋值 字符串的扩展 函数的扩展 数组的扩展 对象的扩展 Promise 对象 async 函数 在此次教程中将会展示 es6 大量的新语法进行，只有不断的进行尝试，才能有不同的成效。 本课程的优势如果你想快速上手进行一个特别面向 C 端的 Mobile 产品开发，甚至是一个中大型的项目开发，如果你能完全阅读完所有课程，并且跟着一步步实践，那么你同样也能给自己的C端产品设计一套属于自己的组件库，毕竟通用型的组件库仍然具备面对市场竞争需求的独特性。 本课程分享的内容是 Vue 的最新版本，可以说这是一套独一无二的教程，不但会结合官方教程和 Api，最主要的是告诉大家在什么场景用什么方式组织代码，避开不必要的坑。 数据驱动架构体系永远离不开组件模式。在这里我会给大家分享级别组件的划分内部原则性，在自己打造组件库的同时，也大量借鉴了各大厂商团队的优秀组件写法，进行比对优缺点，总结相应的理论。 课程大纲如下 01 开启 Vue 之旅 02 灵活的 data，死板的 props 03 $on ， $emit ， v-on 三者关系 04 .sync 王者回归，v-model 使命将至 05 $attrs ， $listeners 深组件通信 06 智能组件与木偶组件的正确通信 07 你不知道的中央事件通信 本课设计想法当我在掘金写下第一篇文章的时候，虽然只是很基础的部分，但文章在两天内获得了大量关注，这充分显示出了中国市场的开发者们对 Vue 的渴望程度。与此同时，我也收集到了一些批评意见，对于读者的反馈能及时做出响应才更能体现出一个课程的价值。 不是能写出源码的教程就是对你有帮助，也并不是写的很基础就对你没有帮助。不是每个人都能当大上牛、进入大公司的研发团队，大多数程序员都是面对业务层面的开发。因此如何在市场上有立足之地，能快速接手项目，这才是大部分人应该最需要发力的地方。 学习本课程你需要做些什么？学习本课程的同学需要对 Html 和 JavaScript 的基础知识有一定了解，理解 es6 基础新特性，了解 npm 和 node 的基本用法。 推荐： 阮一峰老师的es6入门 别浪费时间看别的了，如果你能静下来看完整本书，比任何 es6 其它书籍都好，为什么呢？平民化，就像 Vue 一样，很容易让人理解。 同时在学习本教程的时候，尽量跑一遍 Vue 中文官网结合 Api 你能看懂的示例。 cn.vuejs.org/ 可能有些 Api 或者教程只有一个简单的解释，还特别官方话，没关系，跟着我一步一步敲遍所有的 Demo。 开启 Vue 之旅在整理好心情开始旅程之时，我们往往都会带上许多必备工具，同样 Vue 在面向开源之时，周边的身态也向其靠拢。 vue-devtool 以往 Dom 操作的时候，我们都是通过 dubger 断点来进行错点查找和基础数据驱动，dubger 已经派不上什么用场了，只有通过观察数据的变化，才能准确的定位到错识变化的数据和是否执行了需要的事件。 就用商店输入vue自行安装 vue-cli Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目： 进入 Node.js 官网，下载 Node.js 安装包； 为了下载安装包快速一点，走淘宝源进入 cli 终端； 运行npm install -g cnpm --registry=https://registry.npm.taobao.org 全局安装 vue-cli $ npm install --global vue-cli 创建一个基于 webpack 模板的新项目 $ vue init webpack my-project 安装依赖，走你 $ cd my-project $ npm install $ npm run dev 复制代码 打开文件夹，本次教程的示例全部通过 Components 文件夹来定义单个组件，进行 SPA 的应用开发，用单 .vue 文件也更加直观，一个文夹可能是一个 Page，也可能是一个 Component；在开启 Vue 的旅程之时，拿 todo-list 尝试一下它的神奇魔法，通过 Vue 实例和模板进行数据与行为的交互绑定；实例的每个选项如何与定义的模板值进行一一对应，通过数据驱动、事件绑定，来轻松高效的实现一个 todoList 应用。相比 Juqery 这种操作 Dom 的冷兵器时代，给开发者的感觉是完全变了一种模式，延续着 Html 写法的友好性和适应度，同样还提供了 JSX 语法，Vue 官网说是一个渐进式框加，写法也同样是渐近式，让开发者以不畏惧的心态使用，而且 Vue 的数据驱动模式提供了大量的 Api，每个 Api 无论是实例选项还是实例属性都负责着自己的职责，它们就像五金店的零件一样，只有正确的使用每个 Api 特性并且作用到恰当的地方，Vue 工程代码组织结构和后续的维护才会显得易如反掌。在组件化工程化没到来的时候，业务的实现复杂度并不是最难的，反而令人头疼的是对代码后续的版本迭代、重构、复用等一系列问题，希望通过简单的 todo-list 应用，可以对前端开发革命有新的认识！ &lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot; @keyup.enter=&quot;push&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; @click=&quot;deleteItem(index)&quot;&gt; {% raw %}{{index}}{% endraw %} {% raw %}{{item.name}}{% endraw %} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;todo-list&#39;, data () { return { msg: &quot;&quot;, list: [] } }, methods: { push () { this.list.push({name:this.msg}) this.msg = &quot;&quot; }, deleteItem (index) { this.list.splice(index,1) } } } &lt;/script&gt; 复制代码 本章通过这个示例 Demo 表现 Vue 数据驱动式框架运作是如何简单到令人窒息。 一个 todo-list 应用集成了两个事件，两条 data 数据就完成了！ 通过 Template 里的 Html 模版能清楚的观察到绑定信息，数据联动和时时改动： v-model 里的 msg 和实列 data 里存放的数据进行了绑定 @keyup.enter=”push” 对键盘事件 keyup 进行监听，同时用 enter 修饰符进行 enter 按键进行监听，当触行 methods 里的 push 函数，向整个 list 列表里添加一条 object 数据 通过 v-for 指令循环出整个 list 里的数据，循环出相对应的节点数 点击每个节点的时候执行 deleteItem 事件，删除对应的节点 对于往时操作dom写法和当前的数据驱动有什么区别？ 数据渲染，我们会通过第三方的模版引擎，比如 artTemplate，Jade 等等，渲染完毕之后再 append 到根元素中。 Vue 只是通过一个 v-for 指令循环所有对应的节点，先前只要在 Html 中写好循环模板。 执行事件，需要获取 DOM 元素，对 DOM 元素 addEventlistener 事件，再进行函数。 Vue 直接通过你的 Template 集成的模版在需要发生事件的元素上直接绑定事件，只要执行一个 v-on 结合你需要绑定的事件，所有原生的事件都支持。 需要存储数据时，我们需要定一堆变量，有局部变量和全局变量，导致后续的变量难以维护，甚至可能会导致变量名冲突，作用域调用错误，无法准确定位到正确的数据源。 Vue 通过 data 选项，用每个属性去保存渲染的数据和临时过度的数据，用统一 data 选项去保存，让使用者一目了然。 所有执行的函数，无论是事件所需要执行的，还是封装所需要调用的函数，通过函数式声明在 script 标签内写入，代码量大了，也会存在变量名冲突，和无法准确的定位方法。 Vue 通过 Methods 选项专门为事件所执行的函数和所封装需要调用的函数，就像垃圾桶一样，有一个准确的、可投放的位置，需要找到执行和所需调用的函数，直接可以准确定位到 Methods 选项。 平时我们要对有些数据进行一些处理，比方说去除有后空格，按键的定位，都要通过 js 去过滤或者判断。 Vue 提供了大量的修饰符封装了这些过滤和判断，让开发者少写代码，把时间都投入的业务、逻辑上，只需要通过一个. 修饰符去调用。 以上只是一个简单 todo-list Demo 总结出来的例子，文中所提到的也只是部分功能优势，还有很多功能可以让开发路径更加快速。重点在于数据驱动的模式，只要把组件与组件之间的通信掌握了，也就相当于你就手握大半江山，因为一切的一切都是基于组件通信模式和结构用法来的。 下篇课程导读： 数据驱动一切都是一数据，只有灵活把控对数据的理解，才能自如的运用，在 Vue 里灵活的 data，死板的 props，是存放数据的和传递数据的基点。 第02课：灵活的 data，死板的 props事件驱动在前端来说数据驱动式框架，必然离不开事件驱动，事件驱动一定程度上弥补了数据驱动的不足，在 dom操作 的时代通常都是这样操作： 通过特定的选择器查找到需要操作的节点 -&gt; 给节点添加相应的事件监听 响应用户操作，效果是这样： 用户执行某事件（点击，输入，后退等等） -&gt; 调用 JavaScript 来修改节点 这种模式对业务来说是没有什么问题，但是从开发成本和效率来说会比较力不从心，在业务系统越来越庞大的时候，就显得复杂了。另一方面，找节点和修改节点这件事，效率本身就很低，因此出现了数据驱动模式。 数据驱动 读取模板，同时获得数据，并建立 VM( view-model ) 的抽象层 -&gt; 在页面进行填充 要注意的是， MVVM 对应了三个层， M - Model ，可以简单的理解为数据层； V - View ，可以理解为视图，或者网页界面； VM - ViewModel ，一个抽象层，简单来说可以认为是 V 层中抽象出的数据对象，并且可以与 V 和 M 双向互动 （一般实现是基于双向绑定，双向绑定的处理方式在不同框架中不尽相同）。 用户执行某个操作 -&gt; 反馈到 VM 处理（可以导致 Model 变动） -&gt; VM 层改变，通过绑定关系直接更新页面对应位置的数据 可以简单地理解：数据驱动不是操作节点的，而是通过虚拟的抽象数据层来直接更新页面。主要就是因为这一点，数据驱动框架才得以有较快的运行速度（因为不需要去折腾节点），并且可以应用到大型项目。 Vue 模式Vue 通过 {{}} 绑定文本节点， data 里动态数据与 Props 静态数据进行一个映射关系，当 data 中的属性或者 props 中的属性有变动，以上两者里的每个数据都是行为操作需要的数据或者模板 view 需要渲染的数据，一旦其中一个属性发生变化，则所有关联的行为操作和数据渲染的模板上的数据同一时间进行同步变化，这种基于数据驱动的模式更简便于大型应用开发。只要合理的组织数据和代码，就不会显得后续皮软。 何为动态数据 data，何为静态数据 props相同点两者选项里都可以存放各种类型的数据，当行为操作改变时，所有行为操作所用到和模板所渲染的数据同时都会发生同步变化。 不同点Data 被称之为动态数据的原因，在各自实例中，在任何情况下，我们都可以随意改变它的数据类型和数据结构，不会被任何环境所影响。 Props 被称之为静态数据的原因，在各自实例中，一旦在初始化被定义好类型时，基于 Vue 是单向数据流，在数据传递时始终不能改变它的数据类型。 更为关键地是，对数据单向流的理解， props 的数据都是通过父组件或者更高层级的组件数据或者字面量的方式进行传递的，不允许直接操作改变各自实例中的 props 数据，而是需要通过别的手段，改变传递源中的数据。 data 选项当一个实例创建的时候， Vue 会将其响应系统的数据放在 data选项中 ，当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。初始定行的行为代码也都会随着响应系统进行一个映射。 而 data 选项中的数据在实例中可以任意改变，不受任何影响，前提必须数据要跟逻辑相辅相成。 初始化映射&lt;template&gt; &lt;div&gt; &lt;p v-if=&#39;boolean&#39;&gt;true&lt;/p&gt; &lt;p v-for=&#39;value in obj&#39;&gt;{% raw %}{{value}}{% endraw %}&lt;/p&gt; &lt;p v-for=&#39;item in list&#39;&gt;{% raw %}{{item}}{% endraw %}&lt;/p&gt; &lt;p&gt;{% raw %}{{StringMsg}}{% endraw %}&lt;/p&gt; &lt;p&gt;{% raw %}{{NumberMsg}}{% endraw %}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { obj : {a:&#39;1&#39;,b:&#39;2&#39;,c:&#39;3&#39;}, list:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], boolean : true, StringMsg : &#39;hello vue&#39;, NumberMsg : 2.4, } } } &lt;/script&gt; 复制代码 运行代码时，在 data选项 里定义了五种数据类型，通过指令和 {{}} 进行渲染，证实了 data选项 里可以 定义任何数据类型 。 视图与数据映射&lt;template&gt; &lt;div&gt; &lt;p&gt;{% raw %}{{StringMsg}}{% endraw %}&lt;/p&gt; &lt;p&gt;{% raw %}{{NumberMsg}}{% endraw %}&lt;/p&gt; &lt;button @click=&#39;changeData&#39;&gt;改变数据&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { StringMsg : &#39;hello vue&#39;, NumberMsg : 2.4 } }, methods: { changeData () { this.StringMsg = 2.4; this. NumberMsg = &#39;hello vue&#39; } } } &lt;/script&gt; 复制代码 每个.vue 的文件则就是一个实例，在 data 中定义了两种数据： String 类型 Number 类型 同时还定义了一个 changeData 事件。 在运行代码时候， data选项 已经进入了 Vue的响应系统 里， model层 (数据层)与 view层 (视图层)进行了对应的映射，任何数据类型都可以定义。 当用户发生点击操作的时候，同时可以把 StringMsg， NumberMsg 的数据对调，充分说明了， 无论值和类形都可以进行随意转换 。 行为与数据的映射&lt;template&gt; &lt;div&gt; &lt;p&gt;{% raw %}{{StringMsg}}{% endraw %}&lt;/p&gt; &lt;p&gt;{% raw %}{{NumberMsg}}{% endraw %}&lt;/p&gt; &lt;button @click=&#39;changeData&#39;&gt;改变数据&lt;/button&gt; &lt;button @click=&#39;findData&#39;&gt;查看数据&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { StringMsg : &#39;hello vue&#39;, NumberMsg : 2.4 } }, methods: { changeData () { this.StringMsg = 2.4; this.NumberMsg = &#39;hello vue&#39; }, findData () { console.log( `StringMsg: ${this.StringMsg}` ) console.log( `NumberMsg: ${this.NumberMsg}` ) } } } &lt;/script&gt; 复制代码 改变数据以后，通过点击 findData 事件来进行验证，虽然在初始化定义好了行为数据的检测代码，但是当数据在执行 findData 之前先执行 changeData，一旦改变 data 选项里的数据时，findData 里对应的数据同时也会进行相应的映射。 this. StringMsg //=&gt; 2.4 this. NumberMsg //=&gt;’hello vue’ 总结： data 选项里的数据是灵活的 可以定义任何数据类型 也可以改变成任何数据类型 当数据变化时，视图和行为绑定的数据都会同步改变 props使用 props 传递数据作用域是孤立的，它是父组件通过模板传递而来，想接收到父组件传来的数据，需要通过 props选项 来进行接收。 子组件需要显示的声明接收父组件传递来的数据的 数量 ， 类型 ， 初始值 。 简单的接收可以通过数组的形式来进行接收。 父组件&lt;template&gt; &lt;div&gt; &lt;demo :msg=&#39;msgData&#39; :math = &#39;mathData&#39; &gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { data () { return { msgData:&#39;从父组件接收来的数据&#39;, mathData : 2 } }, components : { Demo } } &lt;/script&gt; 复制代码 子组件&lt;template&gt; &lt;div&gt; &lt;p&gt;{% raw %}{{msg}}{% endraw %}&lt;/p&gt; &lt;p&gt;{% raw %}{{math}}{% endraw %}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [ &#39;msg&#39; , &#39;math&#39;], } &lt;/script&gt; 复制代码 在子组件中需要通过显示定义好需要从父组件中接收那些数据。 同样的在父组件中在子组件模板中过 v-bind 来传递子组件中需要显示接收的数据。 语法： ：== v-bind(是封装的语法糖) ：msg = msgData msg 第一个参数必须要与子组件的 props 同名 msgData 则是父组件中需要向子组传递的数据 props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。 父组件&lt;template&gt; &lt;div&gt; &lt;demo :fn = &#39;myFunction&#39; &gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { components : { Demo }, methods: { myFunction () { console.log(&#39;vue&#39;) } } } &lt;/script&gt; 复制代码 子组件&lt;template&gt; &lt;div&gt; &lt;button @click=&#39;fn&#39;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [ &#39;fn&#39; ], } &lt;/script&gt; 复制代码 同样，在父组件中也可以向子组件中传递一个 function ，在子组件同样也可以执行父组件传递过来的 myFunction 这个函数。 字面量语法和动态语法对于字面量语法和动态语法，初学者在父组件模板中向子组件中传递数据时加和不加 v-bind 有什么区别，同时会引起什么错语等问题会感觉迷惑。 在子组件模板上传递数据时加 v-bind 意味着什么 ？v-bind:msg = &#39;msg&#39; 通过 v-bind 进行传递数据并且传递的数据并不是一个字面量，双引号里的解析的是 一个表达式 ，同样也可以是实例上定义的数据和方法(其实就是引用一个变量）”。 msg=&#39;11111&#39; 没有 v-bind 的模式下只能传递一个字面量，这个字面量只限于 String 类量，字符串类型。 注意： 虽然通过字面量模式下，传任何类型都会被转成字符串类型，但是在子件接收的时候可以通过 typeof 去进行类型检测。 字面量写法除了 String 类型想通过字面量进行数据传递时，如果想传递 非String类型 ，必须 props 名前要加上 v-bind ，内部通过实例寻找，如果实例方没有此属性和方法， 则默认为对应的数据类型 。 :msg=&#39;11111&#39; //number :msg=&#39;true&#39; //bootlean :msg=&#39;()=&gt;{console.log(1)} //function :msg=&#39;{a:1} //object 子组件模板 props 定义问题1.0版本时HTML 特性是不区分大小写的，所以当使用的不是字符串模板，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名。 注意由于文档上仍然有这句话，经过测试后，无论是不是字符串模板，camelCased (驼峰式) 和 kebab-case (短横线隔开式) 两者都可以。 建议为了直观性，规范性还是推荐 kebab-case (短横线隔开式)。 对象传递简写props 原子化可以让整体代码逻辑和向外暴露需要传递数据的接口非常清晰，但是同样可以把子组件需要接收的 props 在父组件中以一个对象进行传递。 当传递的数量一旦多到已经让原子化不再结构清晰的时候，通过一个对象传递显得更为简洁明了。 父组件&lt;template&gt; &lt;div&gt; &lt;demo v-bind= &#39;msg&#39; &gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { components : { Demo }, data () { return { msg : {a:1,b:2} } } } &lt;/script&gt; 复制代码 子组件&lt;template&gt; &lt;div&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [&#39;a&#39;,&#39;b&#39;], created () { console.log(this.a) console.log(this.b) }, } &lt;/script&gt; 复制代码 内部发生了什么？在子组件模板内部对其 进行了一个封装 ，把其展开则跟 props 原子化原理是一个原理 通常情况下建议使用第二种，props 原子化。 不可变的 props在 data 选项中，当前实例（当前组件中改动）可以 任意改变data选项里的数据 ， Vue 传递数据时是基于 数据单向流动 ，子组件不能改变当前实例中的 props 任何属性，需要通知父组件改变相应的值，重新改变。 直接改变 props 数据&lt;template&gt; &lt;div&gt; &lt;button @click=&#39;changeProps&#39;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [&#39;msg&#39;], methods: { changeProps () { this.msg = &#39;new msg&#39; } } } &lt;/script&gt; 复制代码 直接改变 props 时会发生一个警告报错 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “msg” 防止数据的 不可控性 ，不能显示的直接改变，父组件的传递来的数据和子组接 props 接收的数据也是同步响应的，一旦父组件向下传递的数据改变时，prop 接收的数据值也会同样发生变化。 单向数据流的原因也是如此，就像河流一样，水只会从高向低流，想让水的质量改变，只有从源头改变。 父组件改动&lt;template&gt; &lt;div&gt; &lt;demo :msg = &#39;msg&#39; &gt;&lt;/demo&gt; &lt;button @click=&#39;msg = &quot;new vue&quot;&#39;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { components : { Demo }, data () { return { msg : &#39;vue&#39; } } } &lt;/script&gt; 复制代码 在父组件中初始化传递过后，想要改变子组件的数据，可以通过再次改变向子组件传递的 msg 数据，子组件渲染的视图同样会跟着同步改动。 一次性传递，过渡改动虽然 props 是不可改动的，上面的 case 是父组件进行改变自身实例的的数据，这个实现很简单，有时经过一次数据传递，不需用父组件再次传递，因为一些需求需要改动 props 数据，可以用过渡的方法，让其转换为一个可变的数据。 过渡到 data 选项中props: [&#39;msg&#39;], data: function () { return { myMsg: this.msg } } 复制代码 在 data 选项里通过 myMsg 接收 props msg 数据，相当于对 myMsg = msg 进行一个赋值操作，不仅拿到了 myMsg 的数据，而且也可以改变 myMsg 数据。 this.myMsg = ‘new Vue’ myMsg 会发生相应的改变。 一次性传递，过滤处理依然是通过 props 一次性接收，想对接收的 prop 进行一些过滤操作再次进行视图渲染，可以在一些计算属性中进行操作，可以 computed 监听 props 里的数据变化，经过过滤操作返回一个需要的值。 props:[&#39;msg&#39;] computed : { computedMsg () { return this.msg + 1 } } 复制代码 注意： 在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。不要对父组件传递来的引用类型数据进行过滤。 下篇导读 本章对 props 和 data 的用法理解已经进行了全面的讲解，通过再次改变传递数据时是在父组件的实例里进行实施的。往往特定的需求和一些组件封装触发传递的命令并不能直接在父组件执行，需要子组件通知上层组件。 再近一步说，子组件改变不了父组件传递的数据，但是子组件可以用通信的方式，通知子组件改动，因此 $on ， $emit ，v-on 深入理解这三者关系尤为重要！ 第03课： emit，v-on 三者关系 用家庭来描述 $emit ， $on 的关系每个 Vue 实例都实现了事件接口： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 如果把 Vue 看成一个家庭（相当于一个单独的 components )，女主人一直在家里指派 ($emit) 男人做事，而男人则一直监听 ($on) 着女士的指派 ($emit)里eventName 所触发的事件消息，一旦 $emit 事件一触发， $on 则监听到 $emit 所派发的事件，派发出的命令和执行派执命令所要做的事都是一一对应的。 Api 中的解释： vm.$emit( event, […args] ) 参数： {string} event [...args] 触发当前实例上的事件。附加参数都会传给监听器回调。 vm.$on( event, callback ) 参数： {string | Array} ` event (数组只在 ` 2.2.0+ ` 中支持) ` {Function} callback 用法： 监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。 &lt;template&gt; &lt;div&gt; &lt;p @click=&#39;emit&#39;&gt;{% raw %}{{msg}}{% endraw %}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, data () { return { msg : &#39;点击后女人派发事件&#39; } }, created () { this.$on(&#39;wash_Goods&#39;,(arg)=&gt; { console.log(arg) }) }, methods : { emit () { this.$emit(&#39;wash_Goods&#39;,[&#39;fish&#39;,true,{name:&#39;vue&#39;,verison:&#39;2.4&#39;}]) } } } &lt;/script&gt; 复制代码 以上案例说了什么呢？在文章开始的时候说了 $emit 的（eventName）是与 $on(eventName) 是一一对应的，再结合以上两人在组成家庭的之前，女人会给男人列一个手册，告诉男人我会派发 $(emit) 那些事情，男人则会在家庭组成之前 $on(eventName) 后应该如何做那些事情。 通过以上说明我来进一步解释一下官方 Api 的意思。 vm.$emit( event, […args] ) 参数： {string} event 第一个参数则是所要派发的事件名，必须是 String 类型的。 故事中就是要告诉男人所需要执行的事情。 [...args] 第二个参数是一个任何数据类型，如果我们需要传入多个不同的数据类型，则可以写入数组中，像这样[object, Boolean, function, string, …]，只要传一个参数，我们则可以直接写入 this.$emit(&#39;wash_Goods&#39;,&#39;fish&#39;) 复制代码 故事中就是给男人的一个手册，告诉男人东西放在哪里，会需要到什么工具等等。 vm.$on( event, callback ) 参数： {string | Array} event (数组只在 2.2.0+ 中支持) 第一个参数是相对于 $emit (eventName) 一一对应的 $on (eventName) ，两者是并存的、必须是 String 类型的。 (数组只在 2.2.0+ 中支持) 或者是 Array 数组中必须包含的是 String 项，后面再具体说。 故事中就是男人在组件一个家庭 (components) 的时候所监听的事件名。 {Function} callback 第二个参数则是一个 function，同样也被叫作之前回调函数，里面可以接收到由 $emit 触发时所传入的参数（如果是单个参数）。 故事中是男人在接收到女人派发的事情该去做那些事情。 {string | Array} event (数组只在 2.2.0+ 中支持) 在2.2中新增这个 Api 牵扯了另一种方式，也存在这其它的独特用法。 继续延续故事，当女人派发的事情多了，我相信作为男人也会觉得很烦，一旦听到事件的时候肯定会很烦躁，总会抱怨两句。 如果女人在组成家庭之前，告诉男人将要监听那些事情，如果做一件事就抱怨一次，启不是多此一举，所以我们可以通过 Array event 把事件名写成一个数组，在数组里写入你所想监听的那些事件，使用共享原则去执行某些派发事件。 &lt;template&gt; &lt;div&gt; &lt;p @click=&#39;emit&#39;&gt;{% raw %}{{msg}}{% endraw %}&lt;/p&gt; &lt;p @click=&#39;emitOther&#39;&gt;{% raw %}{{msg2}}{% endraw %}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, data () { return { msg : &#39;点击后女人派发事件&#39;, msg2 : &#39;点击后女人派发事件2&#39;, } }, created () { this.$on([&#39;wash_Goods&#39;,&#39;drive_Car&#39;],(arg)=&gt; { console.log(&#39;事真多&#39;) }) this.$on(&#39;wash_Goods&#39;,(arg)=&gt; { console.log(arg) }) this.$on(&#39;drive_Car&#39;,(...arg)=&gt; { console.log(BMW,Ferrari) }) }, methods : { emit () { this.$emit(&#39;wash_Goods&#39;,&#39;fish&#39;) }, emitOther () { this.$emit(&#39;drive_Car&#39;,[&#39;BMW&#39;,&#39;Ferrari&#39;]) } } } &lt;/script&gt; 复制代码 以上案例说明了当女人无论是派发 drive_Car 或者是 wash_Goods 事件，都会打印出 事真多 ，再执行一一对应监听的事件。 通常情况下，以上用法是毫无意思的。在平常业务中，这种用法也用不到，通常在写组件的时候，让 $emit在父级作用域中 进行一个触发，通知子组件的进行执行事情。接下来，可以看一个通过在父级组件中，拿到子组件的实例进行派发事件，然而在子组件中事先进行好派好事件监听的准备，接收到一一对应的事件进行一个回调，同样也可以称之为封装组件向父组件暴露的接口。 DEMO 下拉加载 infinite-scroll&lt;template&gt; &lt;div&gt; &lt;slot name=&quot;list&quot;&gt;&lt;/slot&gt; &lt;div class=&quot;list-donetip&quot; v-show=&quot;!isLoading &amp;&amp; isDone&quot;&gt; &lt;slot&gt;没有更多数据了&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;list-loading&quot; v-show=&quot;isLoading&quot;&gt; &lt;slot&gt;加载中&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=&quot;text/babel&quot;&gt; export default { data() { return { isLoading: false, isDone: false, } }, props: { onInfinite: { type: Function, required: true }, distance : { type : Number, default：100 } }, methods: { init() { this.$on(&#39;loadedDone&#39;, () =&gt; { this.isLoading = false; this.isDone = true; }); this.$on(&#39;finishLoad&#39;, () =&gt; { this.isLoading = false; }); }, scrollHandler() { if (this.isLoading || this.isDone) return; let baseHeight = this.scrollview == window ? document.body.offsetHeight : this.scrollview.offsetHeight let moreHeight = this.scrollview == window ? document.body.scrollHeight : this.scrollview.scrollHeight; let scrollTop = this.scrollview == window ? document.body.scrollTop : this.scrollview.scrollTop if (baseHeight + scrollTop + this.distance &gt; moreHeight) { this.isLoading = true; this.onInfinite() } } }, mounted() { this.scrollview = window this.scrollview.addEventListener(&#39;scroll&#39;, this.scrollHandler, false); this.$nextTick(this.init); }, } &lt;/script&gt; 复制代码 对下拉组件加载加更的组件进行了一个简单的封装： data 参数解释： isLoading false 代表正在执行下拉加载获取更多数据的标识 ， true代表数据加载完毕 isDone false 代表数据没有全完加载完毕 ， true 代表数据已经全部加载完毕 props 参数解释： onInfinite 父组件向子组件传入当滚动到底部时执行加载数据的函数 distance 距离滚动到底部的设定值 从此组件中，我们进行每一步的分析 在 mounted 的时候，对 window 对像进行了一个滚动监听，监听的函数为 scrollHandler 当 isLoading，isDone 任何一个为true时则退出 - `isloading` 为 `true` 时防止多次同样加载，必须等待加载完毕 - `isDone` 为 `true` 时说明所有数据已经加载完成，没有必要再执行 `scrollHandler` 同时在$nextTick中进行了初始化监听 loadedDone 一旦组件实例$emit(‘loadedDone’)事件时，执行回调，放开加载权限 finishLoad 一旦组件实例$emit(‘finishLoad’)事件时，执行回调，放开加载权限 再看看 scrollHandler函数里发生了什么 if (this.isLoading || this.isDone) return; 一旦一者为true，则退出，原因在mounted已经叙述过了 if (baseHeight + scrollTop + this.distance &gt; moreHeight) ​ 当在window对象上监听scroll事件时，当滚动到底部的时候执行 - `this.isLoading = true;` 防止重复监听 - `this.onInfinite()` 执行加载数据函数 父组件中调用 infinite-scroll 组件 &lt;template&gt; &lt;div&gt; &lt;infinite-scroll :on-infinite=&#39;loadData&#39; ref=&#39;infinite&#39;&gt; &lt;ul slot=&#39;list&#39;&gt; &lt;li v-for=&#39;n in Number&#39;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/infinite-scroll&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=&quot;text/babel&quot;&gt; import &#39;InfiniteScroll&#39; from &#39;.......&#39; //引入infinitescroll.vue文件 export default { data () { return { Number : 10 } }, methods : { loadData () { setTimeout(()=&gt;{ this.Number = 20 this.$refs.infinite.$emit(&#39;loadDone&#39;) },1000) } } } &lt;/script&gt; 复制代码 在父组件中引入 infinite-scroll 组件 当滑到底部的时候，infinite-scroll 组件组件内部会执行传入的 :on-infinite=&#39;loadData&#39; 函数 同时在内部也会把 Loading 设置为 true，防止重复执行。 在这里用 this.$refs.infinite 拿到 infinite-scroll 组件的实例，同时触发事件之前在组件中 $on 已经监听着的事件，在一秒后进行改变数据，同时发出 loadDone 事情，告诉组件内部去执行 loadDone 的监听回调，数据已经全部加载完毕，设置 this.isDone = true； 一旦 isDone 或者 isLoading 一者为 true ，则一直保持 return退出状态 。 $emit 和 $on 必须都在实例上进行触发和监听。 v-on 使用自定义绑定事件第一阶段 $emit 和 $on 的两者之间的关系讲完了，接下来该说说 v-on 与 $emit 的关系。 另外，父组件可以在使用子组件的引入模板直接用 v-on 来监听子组件触发的事件。 v-on 用接着故事直观的说法就是，在家里装了一个电话，父母随一直听着电话，同样也有一本小册子，在组成家庭之前，也知识要去监听那些事。 Warn不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定 。 上面 Warn 的意思是 $emit和$on只能作用在一一对应的同一个组件实例 ，而 v-on只能作用在父组件引入子组件后的模板上 。 就像下面这样： 就拿官方的这个例子说吧，其实还是很直观的： &lt;div id=&quot;counter-event-example&quot;&gt; &lt;p&gt;{% raw %}{{ total }}{% endraw %}&lt;/p&gt; &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt; &lt;/div&gt; Vue.component(&#39;button-counter&#39;, { template: &#39;&lt;button v-on:click=&quot;incrementCounter&quot;&gt;{% raw %}{{ counter }}{% endraw %}&lt;/button&gt;&#39;, data: function () { return { counter: 0 } }, methods: { incrementCounter: function () { this.counter += 1 this.$emit(&#39;increment&#39;) } }, }) new Vue({ el: &#39;#counter-event-example&#39;, data: { total: 0 }, methods: { incrementTotal: function () { this.total += 1 } } }) 复制代码 这样的好处在哪里？虽然 Vue 是进行数据单向流的，但是子组件不能直接改变父组件的数据，(也不是完全不能，但不推荐用)，标准通用明了的用法，则是通过父组件在子组件模板上进行一个 v-on 的绑定监听事件，同时再写入监听后所要执行的回调。 在 counter-event-example 父组件里，声明了两个 button-count 的实列，通过 data 用闭包的形式，让两者的数据都是单独享用的，而且 v-on 所监听的 eventName 都是当前自己实列中的 $emit 触发的事件，但是回调都是公用的一个 incrementTotal 函数，因为个实例所触发后都是执行一种操作！ 如果你只是想进行简单的进行父子组件基础单个数据进行双向通信的话，在模板上通过 v-on 和所在监听的模板实例上进行 $emit 触发事件的话，未免有点多余。通常来说通过 v-on 来进行监听子组件的触发事件的话，我们会进行一些多步操作。 子组件&lt;template&gt; &lt;div&gt; &lt;p @click=&#39;emit&#39;&gt;{% raw %}{{msg}}{% endraw %}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, data () { return { msg : &#39;点击后改变数据&#39;, } }, methods : { emit () { this.$emit(&#39;fromDemo&#39;) }, } } &lt;/script&gt; 复制代码 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;p&gt;hello {% raw %}{{msg}}{% endraw %}&lt;/p&gt; &lt;demo v-on:fromDemo=&#39;Fdemo&#39;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, data () { return { msg: &#39;数据将在一秒后改变&#39; } }, methods: { waitTime() { return new Promise(resolve=&gt;{ setTimeout(()=&gt; { this.msg = &#39;数据一秒后改变了&#39; resolve(1) },1000) }) }, async Fdemo () { let a = await this.waitTime(); console.log(a) } }, components : { Demo } } &lt;/script&gt; 复制代码 从上面 demo 可以看出当子组件触发了 fromDemo 事件，同时父组件也进行着监听。 当父组件接收到子组件的事件触发的时候，执行了 async 的异步事件，通过一秒钟的等秒改变 msg ，再打印出回调后通过 promise 返回的值。 接下来想通的此例子告诉大家，这种方法通常是通过监听子组件的事件，让父组件去执行一些多步操作，如果我们只是简单的示意父组件改变传递过来的值用此方法就显的多余了。 我们进行一些的改动： children &lt;template&gt; &lt;div&gt; &lt;p @click=&#39;emit&#39;&gt;{% raw %}{{msg}}{% endraw %}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [ &#39;msg&#39; ], methods : { emit () { this.$emit(&#39;fromDemo&#39;,&#39;数据改变了&#39;) }, } } &lt;/script&gt; 复制代码 parent &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;demo v-on:fromDemo=&#39;Fdemo&#39; :msg=&#39;msg&#39;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, data () { return { msg: &#39;数据没有改变&#39; } }, methods: { Fdemo (arg) { this.msg = arg } }, components : { Demo } } &lt;/script&gt; 复制代码 上面 demo 中子组件从父组件接收一个 msg 数据，但是想点击按钮的时候，改变父组件的 msg ，进行父组件的数据改动，同时再次改变子组件的 msg ，但是最简便的方法则是直接改变 prop 里 msg 的数据。但是数据驱动都是单向数据流，为了不造成数据传递的混乱，我们只能依靠一些其它手段去完成，一个小小的传递数据就显得很复杂的了，所以后续我们会讲讲如何去用更简便的 Api 做对应的事。 下篇课程导读： 在2.0初期 .sync 被砍了， v-model 承担起了双向绑定的职责，毕竟 v-model 不是为组件与组件之间数据双向绑定而设计的，用起来总有蹩脚的时候。 2.3 版本的回归，启用了显示通知的形式让双向绑定又活了， .sync 或者 v-model 比 $emit 与 v-on 只是进行简单的父子组件数据交互更加便捷。 第04课：.sync 王者回归，v-model 使命将至上一章我们已经对 $emit和v-on 如何进行数据和行为的交互做了讲解，但如果只是简单用来数据传递改变的话 .sync和v-model 再适合不过了。如果用过1.0的 Vue 的开发者，我相信 .sync 会让你用起来非常便捷，通过双向绑定很简单就能实双，父子组件的双向绑定，2.0为了保持单向数据流的良好性，去除了 .sync 的功能。 官方解释： 1.0 Props 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。 推荐使用 自定义组件事件 自定义输入组件 (使用组件事件) 全局状态管理 通过大量观察，在初期2.0版本中，因为 .sync 并没有回归，只是在2.3进行回归，在组件库中进行数据双向绑定，几乎都是通过 v-model 来进行的。但是无论从语意上还是感观上，给代码维护的感就是不直观，v-model 在开发通常都是结合 Input 输入框来结合进行一个数据绑定，进行父子组件双向绑定，但是相比自定义 v-on 组件事件，无论从代码量，还是用法上更加简洁。 在 Vue 中，有许多方法和 Angular 相似，这主要是因为 Angular 是 Vue 早期开发的灵感来源。然而 Angular 中存在许多问题，在 Vue 中已经得到解决。 官方解释 自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。 &lt;input v-model=&quot;something&quot;&gt; 复制代码 这不过是以下示例的语法糖： &lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt; 复制代码 v-model 其实也是一个语法糖，想要理解这些代码，你要先知道 Input元素 上本身有个 oninput事件 ，这是 HTML5新增加 的，类似 onchange，每当输入框内容发生变化的时候，就会触发 Input事件 ，然后把 Input 输入框中 value 值再次传递给 something。 此时 value 运用在一个 Input 元素上，用：v-bind:value=’something’，意义上面只是把 Input 输入框中的 value 值与 something 作为一一对应的双向绑定，这就像一个循环操作，当再次触发 Input 事件时， input($event.target)对象中的value值会再次改变something 。 这里我们对 v-model 绑定在 Input 元素上进行语法糖上的解析。 既然在元素上能进行双向绑定，那在组件中进行双向绑定又如何实现，原理其实都是一样的，只是应用在自定义的组件上时，拿的并不是 $event.target.value ，因为我此时不作用在 Input 输入框上。 在组件中使用时，它相当于下面的简写：&lt;custom-input v-bind:value=&quot;something&quot; v-on:input=&quot;something = arguments[0]&quot;&gt; &lt;/custom-input&gt; 复制代码 通过以上简写，通过自定事件让 v-model 进行一个父子组件双向绑定的话。 v-bind:value=’something’ 此时 value 是作为子组件接收的 Props 接收的只能是 value 吗？必须是，因为 v-model 是基于 Input 输入框定制的，其中value 值是为 Input 内部定制的 v-on:input=&quot;something = arguments[0]&quot; 复制代码 此时作用在组件上时，v-on 监听的语法糖也会有所改动，监听的并不是 $event.target.value ，而是 回调函数中的第一个参数 。 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo v-model=&quot;show&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false } } } &lt;/script&gt; 复制代码 子组件&lt;template&gt; &lt;div v-show=&quot;value&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;button @click=&quot;close&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;value&#39;], methods: { close () { this.$emit(&#39;input&#39;,false) } } } &lt;/script&gt; 复制代码 这是一个模态框的基本雏形，可以在父组件通过 v-model 来进行 model 框和父组件之间的显示交互。 通过子组件看出 通过props接收了value值 ，当点击关闭的时候还是通过 $emit事件触发input事件 ，然后通过传入 false 参数。 父组件隐式 v-on:input=”something = arguments[0]” 进行了监听，一但 Input 事件触发，父组件就会执行监听回调，从而做到了双向绑定。 checkbox 和 radio 原理 &lt;input type=&quot;checkbox&quot; :checked=&quot;status&quot; @change=&quot;status = $event.target.checked&quot; /&gt; &lt;input type=&quot;radio&quot; :checked=&quot;status&quot; @change=&quot;status = $event.target.checked&quot; /&gt; 复制代码 通过绑定 checked 属性，同样的监听的是 change 事件，无论是 checkbox 还是 radio 在操作的时候都会隐式自动触发一个 change 事件，跟 Input 通过 value 值，Input 触发事件原理绑定是一样的。 定制组件 v-model定制组件，我们就可以 重写v-model里的Props 和 event ，默认情况下，一个组件的 v-model 会使用 value 属性 和 input 事件 ，往往有些时候，value 值被占用了，或者表单的和自定议 v-model的$emit(&#39;input&#39;)事件发生冲突 ，为了避免这种冲突，可以定制组件 v-model，冲突示例。 子组件&lt;template&gt; &lt;div v-show=&quot;value&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt; {% raw %}{{value}}{% endraw %} &lt;button @click=&quot;close&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;value&#39;], methods: { close () { this.$emit(&#39;input&#39;,false) } } } &lt;/script&gt; 复制代码 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo v-model=&quot;show&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false } } } &lt;/script&gt; 复制代码 上面例子可以发现，在子组件中 input中v-model 和 model显示的操作数据共同占用的 props 中的（value） ，同样两者也共同占用了 emit(‘input’) 触发事件，Input 输入框的事件是自动出发，而 model 显示消失是手动触发。 初始化的时候，Input 输入框的值的会被 value 传入的 false 值给自动加上，当改变 Input 输入框的时候，因为冲突而导致报错。 定制 v-model， 通过 model 选项改变 props 和 event 的值，从而解除两者的冲突。 props代替掉原本 value 的值，可以自定义值 event代表掉原本 input 的触发事件，可以自定义触发事件 子组件&lt;template&gt; &lt;div v-show=&quot;show&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt; {% raw %}{{value}}{% endraw %} &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { model: { prop: &#39;show&#39;, event: &#39;close&#39; }, props: [&#39;show&#39;], data () { return { value: 10 } }, methods: { closeModel () { this.$emit(&#39;close&#39;,false) } } } &lt;/script&gt; 复制代码 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo v-model=&quot;show&quot; &gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false } } } &lt;/script&gt; 复制代码 通过 model 选项的改变，把 props 从原本的 value换成了show ， input触发的事件换成了close ，从而两者都不相互依赖，解决了冲突的问题。 有些时候通过父组件中的子组件模板中想传递 value 值，也会导致同样的冲突。 在不用定制组件的情况下，以下的写法，也会同样导致冲突，导致同用一个 value。 &lt;demo v-model=&quot;show&quot; value=&quot;some value&quot;&gt;&lt;/demo&gt; 复制代码 props:[&#39;value&#39;] 复制代码 王者回归 .sync在一些情况下，我们可能会需要对一个 prop 进行『双向绑定』。事实上，这正是 Vue 1.x 中的 .sync 修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了『单向数据流』的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。 在2.0发布一段之后，无论在业务组件还是在功能组件库上面的，大量的子组件改变父子组件的数据和组件库中可能达到大功率的复用，但是在2.3中回归，重新引入了 .sync 修饰符，这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。 之前的例子中，v-model 毕竟不是给组件与组件之间通信而设计的双向绑定，无论从语意上和代码写法上都没有 .sync 直观和方便。 无论从 v-model 还是 .sync 修饰符来看，都离不开 $emit v-on 语法糖的封装，主要目的还是为了保证数据的正确单向流动与显示流动。 &lt;demo :foo.sync=&quot;something&quot;&gt;&lt;/demo&gt; 复制代码 语法糖的扩展： &lt;demo :foo=&quot;something&quot; @update:foo=&quot;val =&gt; something = val&quot;&gt;&lt;/demo&gt; 复制代码 foo 则是 demo 子组件需要从父组件 props 接收的数据 通过事件显示监听 update:foo (foo则是 props 显示监听的数据)，通过箭头函数执行回调，把参数传给 something，则就形成了一种双向绑定的循环链条 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： this.$emit(&#39;update:foo&#39;, newValue) 复制代码 同时父组件 @update:foo 也是依赖于子组件的显示触发，这样就可以很轻松的捕捉到了 数据的正确的流动 。 第一个参数则是 update 是显示更新的事件，跟在后面的 ：foo 则是需要 改变对应的props值 。 第二个参数传入的是你 希望父组件foo数据里将要变化的值 ，以 用于父组件接收update时更新数据 。 子组件&lt;template&gt; &lt;div v-show=&quot;show&quot;&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;show&#39;], methods: { closeModel () { this.$emit(&#39;update:show&#39;,false) } } } &lt;/script&gt; 复制代码 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo :show.sync=&quot;show&quot; &gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false } } } &lt;/script&gt; 复制代码 上面的 case 同样也解决了 model 显示交互操作，从代码的语意上看上去让开发者一目了然，同样也做了 v-model 做不了的事，基于 props 的原子化，对传入的 props 进行多个数据双向绑定 .sync 也能轻松做到。 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo :show.sync=&quot;show&quot; :msg.sync=&quot;msg&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false, msg: &#39;这是一个model&#39; } } } &lt;/script&gt; 复制代码 子组件&lt;template&gt; &lt;div v-show=&quot;show&quot;&gt; &lt;p&gt;{% raw %}{{msg}}{% endraw %}&lt;/p&gt; &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt; &lt;button @click=&quot;$emit(&#39;update:msg&#39;,&#39;改变了model文案&#39;)&quot;&gt;改变文案&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;show&#39;, &#39;msg&#39;], methods: { closeModel () { this.$emit(&#39;update:show&#39;,false) } } } &lt;/script&gt; 复制代码 父组件向子组件 props 里传递了 msg 和 show 两个值，都用了.sync 修饰符，进行双向绑定。 warn子组件改变父组件的数据时，update 冒号后面的参数和父组件传递进来的值是同步的，想改变那个，则冒号后面的值对应的那个，两者是一一对应的，同时也是必填的。 同样还可以在组件 template 里点击执行 click 后不但可以支持回调函数，还可以写入表达式，只是一种直观的表现还是推荐这种写法的。 .sync 修饰符给我们开发中带来了很大的方便，同时在2.0的初期的组件库中大量的 v-model 给开发者用起来还是很别扭，在.sync 回归后同时也会慢慢向.sync 进行一个版本的迁移。 下篇课程导读： 不基于大量行为操作，只是进行一个或多个数据双向组件的时候，可以轻松用 .sync 与 v-model 去化解，往往组件通信并不是你想像的那么轻松简单，在项目复杂的时候，组件如何合理的拆分，会让业务代码的 清晰度 ， 复用率 ， 后续维护都会降低成本 ，有利必有困难，同样会造成组件与组件的深层次传递，那我们如何进行通信呢？第一个想到的办法必然是 Vuex。Vuex 理解其实本质上并不是处理跨度深层次组件而使用的，往往这样会导致大家会滥用 vuex，而 $attrs $listeners 这对兄弟可以很好的帮助你进行深组件的通信。 第05课： listeners 两兄弟 在2.4版本中，有关 $attrs 和 $listeners 这两个实例属性用法还是比模糊，深层次挖掘将会非常有用，因为在项目中深层次组件交互的话可能就需要 Vuex 助力了，但是如果只是一个简单的深层次数据传递，或者进行某种交互时需要向上通知顶层或父层组件数据改变时，杀鸡用牛 VUX 可能未免有点多余！ 什么情况才会显得多余，如果我们纯通过 props 一层一层向下传递，再通过 watch 或者 data 进行过渡，如果只是单向数据深层能传递，进行监听改变深传递的数据，不进行跨路由之间页面的共享的话，用这两个属性非常便捷。 组件与组件之间大胆解耦有些开发者，特别对 Vuex 没有深入理解和实战经验的时候，同时对组件与组件多层传递时，不敢大胆的解耦组件，只能进行到父子组件这个层面，而且组件复用率层面上也有所下降。 $attr 与 interitAttrs 之间的关系interitAttrs：默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 注意：这个选项不影响 class 和 style 绑定。 what?官网上并没有给出一点 demo，语意上看起来还是比较官方的，理解起来总是有点不太友好，通过一些 demo 来看看发生了什么。 子组件&lt;template&gt; &lt;div&gt; {% raw %}{{first}}{% endraw %} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [&#39;first&#39;] } &lt;/script&gt; 复制代码 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;demo :first=&quot;firstMsg&quot; :second=&quot;secondMessage&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { firstMsg: &#39;first props&#39;, secondMessage: &#39;second props&#39; } }, } &lt;/script&gt; 复制代码 父组件在子组件中进行传递 firstMsg 和secondMsg 两个数据，在子组件中，应该有相对应的 props 定义的接收点，如果在 props 中定义了，你会发现无论是 firstMsg 和 secondMsg 都成了子组件的接收来的数据了，可以用来进行数据展示和行为操作。 虽然在父组件中在子组件模版上通过 props 定义了两个数据，但是子组件中的 props 只接收了一个，只接收了 firstMsg，并没有接收 secondMsg，没有进行接收的此时就会成为子组件根无素的属性节点。 ### 事件代理当我们用 v-for 渲染大量的同样的 DOM 结构时，但是每个上面都加一个点击事件，这个会导致性能问题，那我们可以通过 HTML5 的 data 的自定义属性做事件代理。#### 父组件改动&lt;template&gt; &lt;div class=&quot;hello&quot; @click=&quot;ff&quot;&gt; &lt;demo :first=&quot;firstMsg&quot; :data-second=&quot;secondMsg&quot;&gt;&lt;/demo&gt; &lt;demo :first=&quot;firstMsg&quot; :data-second=&quot;secondMsg&quot;&gt;&lt;/demo&gt; &lt;demo :first=&quot;firstMsg&quot; :data-second=&quot;secondMsg&quot;&gt;&lt;/demo&gt; &lt;demo :first=&quot;firstMsg&quot; :data-second=&quot;secondMsg&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { firstMsg: &#39;first props&#39;, secondMsg: &#39;secondMsg&#39; } }, methods: { ff (e) { if(e.target.dataset.second == &#39;secondMsg&#39;) { console.log(&#39;通过事件委托拿到了自定义属性&#39;) } } } } &lt;/script&gt; 复制代码经过改动之后，在父组件中，把向子组件传递的参数名改成了 HTML 自定义的 data-second 属性，同样在子组件中不进行 props 接收，就顺其自然的成为了子组件每一个根节点的自定义属性。通过事件冒泡的原理，然而可以从e.target.dataset.second 就能找对应的 Dom 节点进行逻辑操作。同样，在子组件模版上可以绑定多个自定义属性，在子组件包裹的外层进行一次监听，通过 data 自定义属性拿到循环出来组件的对应的数据，进行逻辑操作。interitAttrs = false 发生了什么 ？&lt;template&gt; &lt;div&gt; {{first}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [&#39;first&#39;], inheritAttrs: false, } &lt;/script&gt; 复制代码对子组件进行一个改动，我们加上 inheritAttrs: false，从字面上的翻译的意思，取消继承的属性，然而 props 里仍然没有接收 seconed，发现就算 props 里没有接收 seconed，在子组件的根元素上并没有绑定任何属性。&gt; $attrs包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 props 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建更高层次的组件时非常有用。在前面的例子中，子组件 props中并没有接受seconed ， 设置选项 inheritAttrs： false ，同样也不会作为根元素的属性节点，整个没有接收的数据都被 $attr 实例属性给接收，里面包含着所有父组件传入而子组件并没有在 Props里显示接收的数据。为了验证事实，可以在子组件中加上created () { console.log(this.$attrs) } 复制代码打印出来则是一个对象 {second: “secondMsg”, third: “thirdMsg”}### warn想要通 $attr 接收，但必须要保证设置选项 inheritAttrs: false，不然会默认变成根元素的属性节点。开头说了，最有用的情况则是在深层次组件运用的时候，创建第三层孙子组件，作为第二层父组件的子组件，在子组件引入的孙子组件，在模版上把整个 $attr 当数作数据传递下去，中间则并不用通过任何方法去手动转换数据。#### 子组件&lt;template&gt; &lt;div&gt; &lt;next-demo v-bind=&quot;$attrs&quot;&gt;&lt;/next-demo&gt; &lt;/div&gt; &lt;/template&gt; 复制代码#### 孙子组件&lt;template&gt; &lt;div&gt; {{second}}{{third}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props : [ &#39;second&#39; , &#39;third&#39;] } &lt;/script&gt; 复制代码孙子组件在 props 接收子组件中通过 $attr 包裹传来的数据，同样是通过父组件传来的数据，只是在子组件用了 $attrs 进行了统一接收，再往下传递，最后通过孙子组件进行接收。以此类推孙子组件仍然不想接收，再传入下级组件，我们仍然需要对孙子组件实力选项进行设置选项 inheritAttrs: false，否则仍然会成为孙子组件根元素的属性节点。从而利用 $attrs 来接收 props 为接收的数据再次向下传递是一件很方便的事件，深层次接收数据我们理解了，那从深层次向层请求改变数据如何实现。意思就是让顶层数据和最底层数据进行一个双向绑定。### $listenerslisteners 可以认为是监听者。向下如何传递数据已经了解了，面临的问题是如何向顶层的组件改变数据，父子组件可以通过 v-model，.sync，v-on 等一系列方法，深层及的组件可以通过 $listeners 去管理。$listeners 和 $attrs 两者表面层都是一个意思， $attrs 是向下传递数据， $listeners 是向下传递方法，通过手动去调用 $listeners 对象里的方法，原理就是 $emit 监听事件， $listeners 也可以看成一个包裹监听事件的一个对象。### 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; {{firstMsg}} &lt;demo v-on:changeData=&quot;changeData&quot; v-on:another = &#39;another&#39;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { firstMsg: &#39;父组件&#39;, } }, methods: { changeData (params) { this.firstMsg = params }, another () { alert(2) } } } &lt;/script&gt; 复制代码在父组件中引入子组件，在子组件模板上面进行 changeData 和 another 两个事件监听，其它这两个监听事件并不打算被触发，而是直接被调用，再简单的理解则是向下传递两个函数。` 子组件 import NextDemo from './nextDemo.vue' export default { name: 'demo', components: { NextDemo }, created () { console.log(this.$listeners) }, } 复制代码 在子组件中，引入孙子组件 nextDemo。在子组件中像 `$attrs` 一样，可以用 `$listeners` 去整体接收监听的事件， `{changeData: ƒ, another: ƒ}` 以一个对象去接收，此时在父组件中子组件模板上监听的两个事件不但可以被子组件实例属性 `$listeners` 去整体接收，并且同时可以在子组件进行触发。 同样在孙子 nextDemo 组件中，继续向下传递，通过 v-on 把整个 `$listeners` 所接收的事件传递到孙子组件中，只是通过 `$listeners` 把其所有在父组件拿到监听事件一并通过 `$listeners` 一起传递到孙子组件里。 #### 孙子组件 孙子组件 export default { name: 'demo', created () { console.log(this.$listeners) }, } 复制代码 依然能拿到从子组中传递过来的 `$listeners` 所有的监听事件，此时并不是通过 `$emit` 去触发，而是像调用函数一样， `$emit` 只是针对于父子组件的双向通信， `$listeners` 包了一个对象，分别是 changeData 和 another，通过$listeners.changeData(&#39;change&#39;)等于直接触发了事件，执行监听后的回调函数，就是通过函数的传递，调用了父组件的函数。 通过 `$attrs` 和 `$listeners` 可以很愉快地解决深层次组件的通信问题，更加合理的组织你的代码。 &gt; 下篇导读 以上介绍了如何在高层组件向下传递数据，在底层组件向上通知改变数据或者进行一些行为操作，而 `$listeners` 就像是调用了父组件的函数一样，看上去根本没有什么区别，你可能会想用 `$parents，$children` 一样能做到。不是不可用，而是在什么情况下适合用，通过下篇介绍木偶组建和智能组件好好理一下正确场景下如何准确利用 Api 进行行为交互、数据交互。 ## 第06课：智能组件与木偶组件的正确用法 Vue 中在组件层面的数据和行为通信，前五章通过一些 demo 和进行了深入总结，包括以下几点： * data 与 props 的数据存放要素 * 单个组件 `$emit` 与 `$on` 的通信，父子组件 v-on 与 `$emit` 的通信 * .sync 和 v-model 双向绑定的模式 * `$attrs` 与 `$listeners` 深层次数据传递与行为交互的运用模式 以上涵盖了大量组件与组件之间的通信模式，只有能熟练掌握以上知识点，接下来才能对智能组件与木偶组件写法和封装有准确用法。 ### 智能组件原理 智能组件可以称为第三方通用组件，也可以称之为业务型公用组件，与父组件之间的关系是完全解耦的，只能通过 props 进行数据传递，event 进行事件传递，不依赖于任何环境，只需要传递相应的数据和事件，就能得到你想要的操作。 ### 木偶组件原理 木偶组件是为了业务页面进行拆分而形成的组件模式。比如一个页面，可以分多个模块，而每一个模块与其余页面并没有公用性，只是纯粹拆分。 还有一个方面则是复合组件的联动用法。当一个智能组件是由两个组件组成的一个复合智能组件，而它的子组件与父组件之间就有一个木偶的原理，因为两者是相互的，在开发者调用并需保持它们的关系性、规范性，一旦改变其本身的模式则会无效。 &gt; 木偶组件的拆分简便用法 对于每一个木偶组件在定义之前，你必然会知道它将作用于哪个页面，在哪一层，都是有一个准确的不变性，取决于你对页面的拆分深度和数量。 ### $parent 组件通信 `$parent` 指向当前组件的父组件，可以拿到父组件的整个实例。前面已经说了，木偶组件可以明确的知道运用在每个 spa 页面对应路由的第几层组件，可能是当前页面的子组件，孙子组件，或者更深的层次。而想和父组件进行通信的话，在不考虑复用的前题下，可以明确如何与父组件进行数据通信或者行为通信。 ### 父组件 {{msg}} import Demo from './Demo.vue' export default { name: 'hello', components: { Demo }, data () { return { msg: '父组件', } } } 复制代码 ``` ### 子组件 ``` {{demoMsg}} 子组件 export default { name: 'demo', data () { return { demoMsg : '' } }, methods: { handleClick () { let msg = this.$parent.msg this.demoMsg = msg this.$parent.msg = '父组件数据被改了' } } } 复制代码 demo 组件已经明确的知道是 Hello 组件的子组件，也可以是 demo 组件是 Hello 组件的木偶组件，通过 `$parent` 就可以随意取到和改动父组件实例的属性（数据）。同样这也并不违反数据的单向流的原则，可以对比一下通过 v-on 和 `$emit` 或者 v-model，.sync 这几种方法，不但方便很多，还更加快捷，并且明确了组件的位置，就像木偶一样，永远不会变，它的父组件永远只会是同一个。 #### $parent 调用父组件方法 父组件 …methods : { parentMethods () { console.log(‘调用父组件的方法’) }}复制代码 #### 子组件 this.$parent.parentMethods()复制代码 同样可以调用父件的方法，通过子组的调用去执行父组件的方法。此方法是在父组件内部执行的，在某些场景下就会显得很便捷，后面会给出例子。 ### $children 的组件通信 `$children` 也是针对于木偶组件的应用，它和 `$parent` 相反，此 Api是对于一个组件来说，已经明确知道它的子组件，也可能是一个子组件集，准确地拿到想要的子组件实例，或者子组件集实列 `$children` 可以通过父组件拿到子组件的实例，它是以一个数组的形式包裹。 ### 父组件 父组件 import Demo from './Demo.vue' export default { name: 'hello', components: { Demo }, methods: { handlerClick () { console.log(this.$children) this.$children.forEach(item => { item.demoMsg = '通过$children改变' }) } } } 复制代码 ``` #### 子组件 ``` {{demoMsg}} export default { name: 'demo', data () { return { demoMsg : '' } } } 复制代码 ``` 此时已经不是通过子组件去与父组件通信，而是用父组件与子组件通信， `$parent` 与 `$children` 就形成了一个父子组件互相通信的机制，还是那句重点一句 `只适合木偶组件的模式` 。 在父组件中明确 demo 组件是子组件，通过 `$children` 拿到所有 demo 组件的实例，通过 forEach 循环改变每个子组件的实例属。因为 data 里所有属性(数据)都是通过 object.defineproperty 来进行数据劫持，把 data 里的属性都绑到 Vue 实例上。从中我们可以轻而易举的得到它。 > 智能组件的运用 智能组件可能是业务组件也可能是第三方通用组件，总归是多个组件公用的子组件，因为它可能服务多个组件或者页面，当嵌入不同组件里，所需要展求的业务能力也是有所区别的，因此称之为智能组件。 #### 举一个例子： 比方说一个智能组件 A，将嵌入 B，C 组件做为子组件： 当A嵌入到B中需要显示文案 `嵌入B组件中` 当A嵌入到C中需要显示文案 `嵌入C组件中` 通过向智能传递一个数据和标识，告诉它我需要你展示什么？ #### 父组件 ``` 父组件 import Demo from './Demo.vue' export default { name: 'hello', components: { Demo } } 复制代码 #### 子组件 {{type==='B'?'嵌入B的组件':'嵌入C的组件'}} export default { name: ‘demo’, props: [‘type’]}复制代码对于智能组件你永远不知道你将作用于哪个组件之下，这本身就是一个不定因素，特别对于通用组件，这将会暴露各种方法和 props 数据，只有传递数据传递事件去做自己想做的事件，智能组件（也是一个封装模块），会根据传入的数据和事件去做内部封装后所做的事情，而你并不可以轻意的随便改动它。 ### 智能组件里的木偶组件 智能组件与木偶组件同时可以相互嵌套，可以作用在 `复合组件上` 。一般复合组件是都是通三方通用组件称之为智能组件，但是复合组件的父组件和子组件同样可以互相成为对方的 `木偶组件` ，两者可以成为 `相互依赖的关系` 。无论从代码量和理解，调用都会很方便，木偶组件相比智能组件 `更方便理解和简洁` ，但是 `功能上就比较单一` 。 #### 通过一个 accordion 折叠面板来理解智能组件中的木偶组件 accordion属于第三方通用组件，同样也是一个复合组件。 #### Accordion 组件 export default { props : [‘repeat’], methods : { open (uid) { this.$children.forEach(item =&gt; { if(item._uid != uid){ item.close = false } }) } } }复制代码#### AccordionItem 组件 {{title}} export default { props : [‘title’], data () { return { close : false } }, created () { if(this.$parent.repeat === true) { this.close = true } }, methods : { handleClick () { this.$parent.open(this._uid) this.close = !this.close } } }复制代码 ### 最后的调用 vue vue-router vuex import Accordion from ‘./accordion.vue’ import AccordionItem from ‘./accordion-item.vue’ export default { name: ‘hello’, components: { Accordion, AccordionItem } }复制代码 先从智能组件这个方面说起，无论是 accordion 还是 accordion-item 同向外暴露一个 props进行你希望的操作。 accordion 暴露了一个 repeat，当 repeat 为 true 的时候则把所有 item 项初始化都进行展开。 accordion-item 暴露了一个 title，可以随意传入你想设计的标题。 以上这些往往都是一些不定因素，也不知道它可能会嵌套在哪个页面组件的哪一层，这就是复合组件的智能方面。 再从木偶组件这个方面论一下。accordion 与 accordion-item 两者是父子组件关系，这种关系是不可变的，想要用到这个复合组件，accordion 与 accordion-item 必须保证确定的父子组件关系，并且缺一不可，从中就能体现出两者的木偶性。 accordion-item 通过 `$parent` 调用 accordion 父组件的 open 方法， 而 accordion 通过 `$children` 拿到每一个 accordion-item 子组件的实例，进行显示隐藏的转换。两者很充分形成了一个对木偶关系，这种父子关系是永远断不了的。 &gt; 总结： 木偶组件：子组件只能有一个爹，必须是唯一的，而且父子俩长得一模一模，谁离开谁都活不了。 智能组件：子组件可以有N个爹，非唯一性，而且父子长得不一定要一样，子组件可能会有N个爹的特性，子组件离开哪个爹都能继续生存。 ## 第07课：你不知道的中央事件通信 中央事件通信，就像一根线一样，把两个组件的通信用一根线连接起来。前面几节课讲了父子组件通信与深层次嵌套组件通信，并且已经通过各种 Api 和良好的解决方案，但是同级组件怎么办，无论用 `$emit` `v-on` `v-model` `.sync` `$attr与$listeners` 都不适用，以上这些都是 `基于嵌套的父子组件进行通信` 。 &gt; 同级组件通信，也是一种常见的通信模式，在一个大的容器下(父组件)底下有两个平级的组件，两个组件进行数据交或者行为交互，在 Api 的方法里也没有专门的设计。 ### 通过 `$emit` ，v-on， `$on` 三者结合使用 这种操作是非常复杂的，如果你能良好掌握以上三个 Api 进行同级组件的通信，那你对这三个 Api 已经完全掌握了。这种方法是一种过渡方法， `b-&gt;a` `a-&gt;c` ，意思是 `a` 去通知 `b` ， `b` 对 `a` 进行一个监听，当 `a` 监听到件事，在进行向 `c` 触发， `c` 的内部再进行监听，这样就形成了一个过渡链条。但是代码上就不显的那么直观了，多个触发事件，多个监听事件，一旦这种平级组件需要通信多了，那么代码就有一种很难维护的感觉。 &gt; 实例demo ### 同级子组件 First first组件 export default { name: ‘first’ }复制代码 按着上面的讲解的顺序，先定义一个同级子组件，当点击的时候向外触发一个 `eventName` 为 `fromFirst` 的事件，传递一个 `来自A组件` 的参数这就形成了 `b-&gt;a` 让 `a` 去监听事件，让 `b` 去触发事件。 ### 父组件 父组件 import First from ‘./first.vue’ import Second from ‘./second.vue’ export default { name: ‘login’, components: { First, Second }, methods: { hanlderFromA (Bmsg) { let second = this.$refs.second second.$emit(‘fromLogin’, Bmsg) } } }复制代码* 父组件中引入了两个同级组件 `First` / `Second` ，还是延续 `b-&gt;a` 。此时 `a` 就是这个父组件，再梳理一下知识点， `v-on与$emit` 是进行 `父子组件事件通信` ，作用在父子组件两个层面上，在 `First` 组件模版上进行一个 `v-on监听` ，一旦监听到触发 `fromFirst` 事件，则进行 `hanlderFromA` 函数。 * 接下来是 `a-&gt;c` 这个阶段， `$emit与$on` 都是作用在同一个组件的实列上，通过 `this.$refs` 拿到 `Second` 组件的实列，在执行 `hanlderFromA函数` 时再告诉 `c` 组件进行通信，同时把从 `b` 接收到的参数再次传入。 以上很明显能看出 A（父组件）只是一个过渡体，也可以说是一个真实的中央体，进行中央事件的派发。 ### 同级子组件 Second {{Bmsg}} second组件 export default { name: ‘second’, created () { this.$on(‘fromLogin’, (Bmsg) =&gt; { this.Bmsg = Bmsg console.log(‘通信成功’) }) }, data () { return { Bmsg: ‘’ } } }复制代码 Second 组件是被通信的一方，在 `a(父组件)` 进行触发，然而在 `c(second)` 组件中进行监听，一旦监听到了 `fromLogin` 事件，可以做你想做得改变数据，行为操作都不是问题了。 这就 `是b-&gt;a a-&gt;c` 的模式，我只能用一句话说，复杂！实在是复杂，那必然有简单的方法。在了解更简单的方法之前，先了解一下 `ES6 模块的运行机制` 。 &gt; ES6 模块的运行机制 JS 引擎对脚本静态分析的时候，遇到模块加载命令 `import` ，就会生成一个 `只读引用` 。ES6 export 的原始值变了， `import加载` 的值也会跟着变。因此， `ES6` 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 &gt; 举个例子 // lib.jsexport let counter = 3;export function incCounter() { counter++;} // main.jsimport { counter, incCounter } from ‘./lib’;console.log(counter); // 3incCounter();console.log(counter); // 4复制代码 虽然在 `main.js` 执行程序的时候加载了 `count` ，但是 `count` 在 `lib.js` 和在 `main.js` 里形成了一个引用关系，一旦libs内部的 `export` 导出的 `counter` 发生变化时， `main.js` 中同样会发生变化。 &gt; 通过额外的实例进行简单的中央事件处理 定义一个额外的实例进行一个事件的中转，对于 `ES6` 模块的运行机制已经有了一个讲解，当模块内部发生变化的时候，引入模块的部分同样会发生变化，当又一个额外的实例对加载机制进行引入进行 `$emit与$on` 进行绑定通信，能轻而易举解决问题，通过 `b-&gt;a-&gt;c` 的模式直接过渡。 &gt; 定义一个中央事件实例 import Vue from ‘vue’ export default new Vue() 复制代码 new 一个 Vue 的实例，然后把这个实例能过 es6 模块机制导出。 ### 父组件改动 父组件 import First from ‘./first.vue’ import Second from ‘./second.vue’ export default { name: ‘login’, components: { First, Second } } 复制代码 在父这里只需要进行两个同组件的引入，可以删除任何过渡的方式。 #### 同级子组件 First 改动 first组件 import Bus from ‘./bus.js’ export default { name: ‘first’, methods: { handleClick () { Bus.$emit(‘fromFirst’, ‘来自A的组件’) } } }复制代码 在 `first同级` 组件中把 `bus` 实例引入，点击时让 `bus` 实例触发一个 `fromFirst` 事件，这里你可能已经理解 module 加载机制配合在单个实例上用 `$emit和$on` 进行通信绑定，往下看。 ### 同级子组件Second改动 {{Bmsg}} second组件 import Bus from ‘./bus.js’ export default { name: ‘second’, created () { Bus.$on(‘fromFirst’, ( Amsg )=&gt; { this.Bmsg = Amsg console.log(‘同级组件交互成功’) }) }, data () { return { Bmsg: ‘’ } } }复制代码 同样也引入 `bus` 实列，通过 `bus` 用 `$on` 监听 `fromFirst` 事件，因为 `bus实例` 与 `bus.js` 里的 `export defalt new Vue` 关系是一个引用关系，当代码执行后，无论 `first` 或者 `second` 组件通过 `bus实例` 形成了一个 `中央事件链条` ，这种方法不但直观，也更加便捷。 &gt; 中央事件的延生 跨组件深层次交互 既然同级组件可以用中央事件去过渡，那深层次嵌套不同级组件可以吗？那你肯定第一时间用到了 Vuex，但我一直认为 Vuex 操作大量的数据联动性非常有用，但是如果只是一个改变数据，或者执行事件，用起来反而更加直观。 &gt; 将要模拟的方案： * a 组件 + first 组件 -&gt; firstInner 组件 + second 组件 -&gt; secondInner 组件 当 `firstInner组件` 可能会与 `second组件` 或者 `secondInner组件` 发生跨组件深层次交互也同样可以用中央事件去进行过渡 `，如果说 vuex 是顶层共享数据源，那么中央事件就是顶层共享通信网` 。 &gt; demo 示例 前面的所有父组件都不写代码了，只展示一下firstInner 组件、secondInner 组件。 ### firstInner 组件 firstInner组件 import Bus from ‘./bus.js’ export default { name: ‘first’, methods: { handleClick () { Bus.$emit(‘fromFirstInner’, ‘来自firstInner组件’) } } }复制代码 ### SecondInner 组件 secondInner组件 import Bus from ‘./bus.js’ export default { name: ‘secondInner’, created () { Bus.$on(‘fromFirstInner’,(msg) =&gt; { console.log(msg) }) } }复制代码` 无论你想通信的两个组件嵌到在任何地方，它们的关系是如何的，只需要通过中央事件的处理，都能完成，同时还可以进行一对多的中央事件处理方式。在程序代码可控的情况下，没有什么是不可行的，只要数据量的变动是在可控范围之内，做一个中央事件网去行成一个通信网络，也是一个不错的选择。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[]},{"title":"let和var的区别","slug":"let和var的区别","date":"2020-05-02T07:15:00.000Z","updated":"2020-06-21T13:10:21.278Z","comments":true,"path":"2020/05/02/let和var的区别/","link":"","permalink":"/2020/05/02/let和var的区别/","excerpt":"","text":"let和var的区别：1.关于重复定义：不同点：​ ①var可以重复定义，新定义的值会覆盖前面定义的，var m=100,m=500;//不会报错。 ​ let不可以重复定义，会报错，let m=100,m=500;// 错误为：Uncaught SyntaxError: Identifier ‘m’ has already been declared ​ 2.关于作用域：相同点：var和let定义的变量都会变量提升不同点：​ ①var定义的变量可以是全局作用域和函数作用域，在全局作用域里面定义之后可以在window中获取的到 &gt;如果在同时在全局和函数里用var定义一个相同的变量，是不会互相影响的； &gt;而var没用块级作用域，如果在if或者for循环这样语句中使用，我们还是可以在全局中访问得到他。 ​ let定义的变量可以是块级作用域，(块级作用域指的是在小括号”()”和花括号”{}”里面的作用域)。 &gt;如果let在if和for循环定义一个变量，这个变量在全局是获取不到的，里面会产生块级作用域。 ​ ②var和let变量提升之后，如果在上面输出var定义的变量会得到undefined，而let定义的变量在上面输出会报错(test.html:10 Uncaught ReferenceError: Cannot access ‘a’ before initialization at test.html:10)，我们把let这种情况叫做暂时性死区。","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"/tags/前端面试题/"}],"keywords":[]},{"title":"Vue面试题13道","slug":"Vue面试题13道","date":"2020-04-27T06:36:39.000Z","updated":"2020-06-21T13:10:21.261Z","comments":true,"path":"2020/04/27/Vue面试题13道/","link":"","permalink":"/2020/04/27/Vue面试题13道/","excerpt":"","text":"1.Vue2.0框架中哪个指令是实现列表渲染的？ A. v-show B. v-repeat C. v-while D. v-for 正确答案：D 2.Vue框架中哪个指令是实现数据双向绑定的？ A. v-show B. v-bind C. v-model D. v-data 正确答案：C 3.Vue框架中计算属性是用哪个关键字？ A. computed B. watch C. created D. computer 正确答案：A 4.Vue框架中以下选项哪几个是常见的事件修饰符? A. native B. stop C. prevent D. enter E. start 正确答案:ABCD 5.Vue框架中v-if和v-show 指令有什么区别？ 答：v-if是对dom节点进行删除或添加，达到隐藏和出现的效果，切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件。 v-show是把节点的display属性设置为none达到隐藏的效果。 6.Vue中全局组件和局部组件的区别？ 答：全局组件：是注册在vm根实例里面的组件，可以在任何地方使用，且已经注册完成，无需注册。 局部组件：利用一个对象的形式来创建，不管是在vm根实例中使用还是在其他vm里面的组件里面使用都要注册，才能在注册的实例中使用。 7.vue-router中的history模式和hash模式有什么区别？ 答：使用url中的hash（#后面的参数）后面的参数来作为路由，通过监听，此参数的变化找到对应的组件及其内容，更新到页面中去，支持所有浏览器。 8.怎么在Vue中点击别的区域输入框不会失去焦点？ 答： 阻止事件的默认行为。 具体操作：监听你想点击后不会丢失input焦点的那个元素的mousedown事件,回调里面调用event.preventDefault()，会阻止使当前焦点丢失这一默认行为。 9.vue中的data属性可以和methods的方法同名吗？为什么？ 答：不可以，会报错; 因为data中的属性和methods中的方法重名时，属性名会覆盖方法名，会报this.*** is not a function的错误。 10.keep-alive内置组件的生命周期有哪些？请具体描述。 答： 1.activated():keep-alive中的组件被激活时触发。 2.deactivated():keep-alive中的组件被暂时挂起时触发。 3.destroyed():keep-alive中的组件被销毁时触发。 11.Vue能监听到的数组变化的方法有哪些？为什么这些方法可以被监听到呢？ 答： push(),pop(),shift(),unshift(),splice(),sort(),reverse(); 因为watch监听是data中的数据变化，而上面这些方法会使原数组发生变化，则watch就能监听到。 12.vue中的计算属性和监听有什么区别？说说各自的特点及其应用场景。 答： 区别： computed： 1.会有缓存，只有依赖数据发生变化时，才会重新计算属性； 2.不支持异步，当computed内有异步操作时无效，无法监听数据的变化； 3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值 watch： 1. 不支持缓存，数据变，直接会触发相应的操作； 2.watch支持异步； 3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 场景：computed在计算数据量较小的时候更好用，而watch用于计算数据量较大的时候才用会更好。 13.请描述vue中的常用生命钩子函数？ 答： beforeCreate： 当实例创建之前触发 created： 当实例被创建的时候触发 beforeMounte： 当实例挂载之前触发 mounted: 当实例被挂载的时候触发 beforeUpdate： 当虚拟DOM重新渲染之前触发 updated： 当虚拟DOM重新渲染时触发 beforeDestroy： 当实例销毁之前触发 destroyed： 当实例销毁后触发","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[]},{"title":"window10专业版命令行快速激活教程","slug":"window10专业版命令行快速激活教程","date":"2020-04-25T12:56:56.000Z","updated":"2020-06-21T13:10:21.322Z","comments":true,"path":"2020/04/25/window10专业版命令行快速激活教程/","link":"","permalink":"/2020/04/25/window10专业版命令行快速激活教程/","excerpt":"","text":"window10专业版命令行快速激活教程1. 在window10搜索cmd命令行，以管理员身份运行。2. 输入：slmgr.vbs /upk （意思是卸载当前产品密钥）3. 输入: slmgr /ipk TX9XD-98N7V-6WMQ6-BX7FG-H8Q99 (安装密钥)4.输入： slmgr /skms zh.us.to (设置计算机名称为zh.us.to)5.激活： slmgr /ato (成功激活)优点：快，方便；缺点：只能激活180天，到期自己再搞一遍，部分机型只能激活45天，不怕麻烦可以搞，我也觉得不麻烦；","categories":[],"tags":[{"name":"window10","slug":"window10","permalink":"/tags/window10/"}],"keywords":[]},{"title":"Vant-weapp框架","slug":"vant_weapp(微信小程序UI框架)","date":"2020-04-21T01:48:05.000Z","updated":"2020-06-21T13:10:21.282Z","comments":true,"path":"2020/04/21/vant_weapp(微信小程序UI框架)/","link":"","permalink":"/2020/04/21/vant_weapp(微信小程序UI框架)/","excerpt":"","text":"介绍Vant Weapp 是移动端 Vue 组件库 Vant 的小程序版本，两者基于相同的视觉规范，提供一致的 API 接口，助力开发者快速搭建小程序应用。 预览扫描下方小程序二维码，体验组件库示例： 快速上手请参考 快速上手 安装步骤一 通过 npm 安装需要注意的是 package.json 和 node_modules 必须在 miniprogram 目录下 # 通过 npm 安装 npm i @vant/weapp -S --production # 通过 yarn 安装 yarn add @vant/weapp --production # 安装 0.x 版本 npm i vant-weapp -S --production 步骤二 构建 npm 包打开微信开发者工具，点击 工具 -&gt; 构建 npm，并勾选 使用 npm 模块 选项，构建完成后，即可引入组件 步骤四 修改 app.json将 app.json 中的 &quot;style&quot;: &quot;v2&quot; 去除，小程序的新版基础组件强行加上了许多样式，难以去除，不关闭将造成部分组件样式混乱。 使用引入组件以 Button 组件为例，只需要在app.json或index.json中配置 Button 对应的路径即可。如果你是通过下载源代码的方式使用 @vant/weapp，请将路径修改为项目中 @vant/weapp 所在的目录。 // 通过 npm 安装 // app.json &quot;usingComponents&quot;: { &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot; } // 通过下载源码使用 es6版本 // app.json &quot;usingComponents&quot;: { &quot;van-button&quot;: &quot;path/to/@vant/weapp/dist/button/index&quot; } // 通过下载源码使用 es5版本 // app.json &quot;usingComponents&quot;: { &quot;van-button&quot;: &quot;path/to/@vant/weapp/lib/button/index&quot; } Vant_weapp在app.json里面的所有组件配置参数&quot;usingComponents&quot;: { &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;, &quot;van-cell&quot;: &quot;@vant/weapp/cell/index&quot;, &quot;van-cell-group&quot;: &quot;@vant/weapp/cell-group/index&quot;, &quot;van-icon&quot;: &quot;@vant/weapp/icon/index&quot;, &quot;van-image&quot;: &quot;@vant/weapp/image/index&quot;, &quot;van-row&quot;: &quot;@vant/weapp/row/index&quot;, &quot;van-col&quot;: &quot;@vant/weapp/col/index&quot;, &quot;van-popup&quot;: &quot;@vant/weapp/popup/index&quot;, &quot;van-transition&quot;: &quot;@vant/weapp/transition/index&quot;, &quot;van-calendar&quot;: &quot;@vant/weapp/calendar/index&quot;, &quot;van-checkbox&quot;: &quot;@vant/weapp/checkbox/index&quot;, &quot;van-checkbox-group&quot;: &quot;@vant/weapp/checkbox-group/index&quot;, &quot;van-datetime-picker&quot;: &quot;@vant/weapp/datetime-picker/index&quot;, &quot;van-field&quot;: &quot;@vant/weapp/field/index&quot;, &quot;van-picker&quot;: &quot;@vant/weapp/picker/index&quot;, &quot;van-radio&quot;: &quot;@vant/weapp/radio/index&quot;, &quot;van-radio-group&quot;: &quot;@vant/weapp/radio-group/index&quot;, &quot;van-rate&quot;: &quot;@vant/weapp/rate/index&quot;, &quot;van-search&quot;: &quot;@vant/weapp/search/index&quot;, &quot;van-slider&quot;: &quot;@vant/weapp/slider/index&quot;, &quot;van-stepper&quot;: &quot;@vant/weapp/stepper/index&quot;, &quot;van-switch&quot;: &quot;@vant/weapp/switch/index&quot;, &quot;van-uploader&quot;: &quot;@vant/weapp/uploader/index&quot;, &quot;van-action-sheet&quot;: &quot;@vant/weapp/action-sheet/index&quot;, &quot;van-dialog&quot;: &quot;@vant/weapp/dialog/index&quot;, &quot;van-dropdown-menu&quot;: &quot;@vant/weapp/dropdown-menu/index&quot;, &quot;van-dropdown-item&quot;: &quot;@vant/weapp/dropdown-item/index&quot;, &quot;van-loading&quot;: &quot;@vant/weapp/loading/index&quot;, &quot;van-notify&quot;: &quot;@vant/weapp/notify/index&quot;, &quot;van-overlay&quot;: &quot;@vant/weapp/overlay/index&quot;, &quot;van-swipe-cell&quot;: &quot;@vant/weapp/swipe-cell/index&quot;, &quot;van-toast&quot;: &quot;@vant/weapp/toast/index&quot;, &quot;van-circle&quot;: &quot;@vant/weapp/circle/index&quot;, &quot;van-collapse&quot;: &quot;@vant/weapp/collapse/index&quot;, &quot;van-collapse-item&quot;: &quot;@vant/weapp/collapse-item/index&quot;, &quot;van-count-down&quot;: &quot;@vant/weapp/count-down/index&quot;, &quot;van-divider&quot;: &quot;@vant/weapp/divider/index&quot;, &quot;van-notice-bar&quot;: &quot;@vant/weapp/notice-bar/index&quot;, &quot;van-panel&quot;: &quot;@vant/weapp/panel/index&quot;, &quot;van-progress&quot;: &quot;@vant/weapp/progress/index&quot;, &quot;van-skeleton&quot;: &quot;@vant/weapp/skeleton/index&quot;, &quot;van-steps&quot;: &quot;@vant/weapp/steps/index&quot;, &quot;van-sticky&quot;: &quot;@vant/weapp/sticky/index&quot;, &quot;van-tag&quot;: &quot;@vant/weapp/tag/index&quot;, &quot;van-tree-select&quot;: &quot;@vant/weapp/tree-select/index&quot;, &quot;van-grid&quot;: &quot;@vant/weapp/grid/index&quot;, &quot;van-grid-item&quot;: &quot;@vant/weapp/grid-item/index&quot;, &quot;van-index-bar&quot;: &quot;@vant/weapp/index-bar/index&quot;, &quot;van-index-anchor&quot;: &quot;@vant/weapp/index-anchor/index&quot;, &quot;van-sidebar&quot;: &quot;@vant/weapp/sidebar/index&quot;, &quot;van-sidebar-item&quot;: &quot;@vant/weapp/sidebar-item/index&quot;, &quot;van-nav-bar&quot;: &quot;@vant/weapp/nav-bar/index&quot;, &quot;van-tab&quot;: &quot;@vant/weapp/tab/index&quot;, &quot;van-tabs&quot;: &quot;@vant/weapp/tabs/index&quot;, &quot;van-tabbar&quot;: &quot;@vant/weapp/tabbar/index&quot;, &quot;van-tabbar-item&quot;: &quot;@vant/weapp/tabbar-item/index&quot;, &quot;van-area&quot;: &quot;@vant/weapp/area/index&quot;, &quot;van-card&quot;: &quot;@vant/weapp/card/index&quot;, &quot;van-submit-bar&quot;: &quot;@vant/weapp/submit-bar/index&quot;, &quot;van-goods-action&quot;: &quot;@vant/weapp/goods-action/index&quot;, &quot;van-goods-action-icon&quot;: &quot;@vant/weapp/goods-action-icon/index&quot;, &quot;van-goods-action-button&quot;: &quot;@vant/weapp/goods-action-button/index&quot; } 详情和使用的其他方法见Vant-weapp官方开发文档","categories":[],"tags":[{"name":"微信小程序UI框架","slug":"微信小程序UI框架","permalink":"/tags/微信小程序UI框架/"}],"keywords":[]},{"title":"webpack优化方案","slug":"webpack优化方案","date":"2020-02-25T00:25:02.000Z","updated":"2020-06-21T13:10:21.311Z","comments":true,"path":"2020/02/25/webpack优化方案/","link":"","permalink":"/2020/02/25/webpack优化方案/","excerpt":"","text":"webpack 是一个现代 JavaScript 应用程序最为火热的静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle ，在项目构建的时候可以根据项目需求配置自己的构建配置来优化构建的速度和项目的加载速度。 我们在这篇文章中主要来说说优化webpack项目构建性能，和对于项目的优化为目的，罗列一些常见的webpack优化方案（配置方面优化 ， 优化插件的使用） 需要优化，是否先得知道当前构建工作流中还存在什么问题吧？ 1. 使用 webpack-bundle-analyzer 来查看构建出来的项目具体情况 cnpm install webpack-bundle-analyzer -D //webpack.config.prod.js const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin; const merge = require(&#39;webpack-merge&#39;); const baseWebpackConfig = require(&#39;./webpack.config.base&#39;); module.exports = merge(baseWebpackConfig, { //.... plugins: [ //... new BundleAnalyzerPlugin(), ] }) npm run build 构建，会默认打开： http://127.0.0.1:8888/，可以看到各个包的体积 2. 使用 webpack-jarvis 相比上面的插件更为直观些（个人觉得）同样可以查看出所有构建的项目在构建的时间和各个chunk的细节。 const Jarvis = require(&quot;webpack-jarvis&quot;); module.exports = merge(baseWebpackConfig, { //.... plugins: [ new Jarvis({ watchOnly: true,//仅仅监听编译阶段 port: 3001 // 会开启一个web ，需要设置查看的端口 }) ] }) 3. 使用speed-measure-webpack-plugin` 来测量各个插件和loader所花费的时间 插件的使用方法很简单，直接将webpack的配置包裹起来即可。 //webpack.config.js const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;); const smp = new SpeedMeasurePlugin(); const config = { //...webpack配置 } module.exports = smp.wrap(config); 下面进入优化的实施细节：1.exclude/include 我们可以通过 exclude、include 配置来确保转译尽可能少的文件。顾名思义，exclude 指定要排除的文件，include 指定要包含的文件。 exclude 的优先级高于 include，在 include 和 exclude 中使用绝对路径数组，尽量避免 exclude，更倾向于使用 include。 //webpack.config.js const path = require(&#39;path&#39;); module.exports = { //... module: { rules: [ { test: /\\.js[x]?$/, use: [&#39;babel-loader&#39;], include: [path.resolve(__dirname, &#39;src&#39;)] } ] }, } 2. cache-loader 在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中。默认保存在 node_modueles/.cache/cache-loader 目录下 //按照正常的loader配置即可 如果只需要配置babel-loader , 可以直接设置 cacheDirectory:true 即可 3.happypack 由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？ HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 const Happypack = require(&#39;happypack&#39;); module.exports = { //... module: { rules: [ { test: /\\.js[x]?$/, use: &#39;Happypack/loader?id=js&#39;, include: [path.resolve(__dirname, &#39;src&#39;)] }, { test: /\\.css$/, use: &#39;Happypack/loader?id=css&#39;, include: [ path.resolve(__dirname, &#39;src&#39;), path.resolve(__dirname, &#39;node_modules&#39;, &#39;bootstrap&#39;, &#39;dist&#39;) ] } ] }, plugins: [ new Happypack({ id: &#39;js&#39;, //和rule中的id=js对应 //将之前 rule 中的 loader 在此配置 use: [&#39;babel-loader&#39;] //必须是数组 }), new Happypack({ id: &#39;css&#39;,//和rule中的id=css对应 use: [&#39;style-loader&#39;, &#39;css-loader&#39;,&#39;postcss-loader&#39;], }) ] } 4.HardSourceWebpackPlugin HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。 配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。 var HardSourceWebpackPlugin = require(&#39;hard-source-webpack-plugin&#39;); module.exports = { //... plugins: [ new HardSourceWebpackPlugin() ] } 5.noParse 如果一些第三方模块没有AMD/CommonJS规范版本，可以使用 noParse 来标识这个模块，这样 Webpack 会引入这些模块，但是不进行转化和解析，从而提升 Webpack 的构建性能 ，例如：jquery 、lodash。 //webpack.config.js module.exports = { //... module: { noParse: /jquery|lodash/ } } 6.resolve中的 modules ， extensions resolve 配置 webpack 如何寻找模块所对应的文件 , modules是指定查找依赖模块的目录（默认就是node_modules ，不建议修改） ，extensions 是指定当没有指定文件扩展名的时候，该怎么去匹配文件，默认是[‘js’,’json’] ，就是说默认先找js文件 ，找不到再使用json ,可以按照项目文件的出现概率去设置。 7.IgnorePlugin 忽略第三方包可能导入的非必须依赖//webpack.config.js module.exports = { //... plugins: [ //忽略 moment 下的 ./locale 目录 new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ] } //以上配置 会在以下方式导入包的时候，只引入手动引入的包 import moment from &#39;moment&#39;; import &#39;moment/locale/zh-cn&#39;;// 手动引入 8.项目生产环境CDN 优化 - externals 经常使用一些第三方的库的时候，我们可以采用CDN方式来加速和降低本地服务器的压力，同样我们也可以使用在webpack中，那么久需要指定一些第三方的库不需要打包出来，我们后期可以通过cdn 在网页中引入即可。 //webpack.config.js module.exports = { //... externals: { //jquery通过script引入之后，全局中即有了 jQuery 变量 &#39;jquery&#39;: &#39;jQuery&#39; } } 9.抽离公共代码 抽离公共代码是对于多页应用来说的，如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载一次就缓存起来了，避免了重复下载。 //webpack.config.js module.exports = { optimization: { splitChunks: {//分割代码块 cacheGroups: { vendor: { //第三方依赖 priority: 1, //设置优先级，首先抽离第三方模块 name: &#39;vendor&#39;, test: /node_modules/, chunks: &#39;initial&#39;, minSize: 0, minChunks: 1 //最少引入了1次 }, //缓存组 common: { //公共模块 chunks: &#39;initial&#39;, name: &#39;common&#39;, minSize: 100, //大小超过100个字节 minChunks: 3 //最少引入了3次 } } } }, runtimeChunk: {//runtimeChunk 的作用是将包含 chunk 映射关系的列表从 main.js 中抽离出来 生成一个mainfest.js 文件 name: &#39;manifest&#39; } } 10. webpack 4.x 自身的优化 tree-shaking 如果使用ES6的import 语法，那么在生产环境下，会自动移除没有使用到的代码 scope hosting 作用域提升，可以减少一些变量声明。在生产环境下，默认开启。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}],"keywords":[]},{"title":"Web Worker的原理","slug":"WebWorker处理大量计算js脚本","date":"2019-11-11T09:27:25.000Z","updated":"2020-06-21T13:10:21.262Z","comments":true,"path":"2019/11/11/WebWorker处理大量计算js脚本/","link":"","permalink":"/2019/11/11/WebWorker处理大量计算js脚本/","excerpt":"","text":"Web Workerweb worker 是运行在后台的 JavaScript，不会影响页面的性能。 = &gt; 单独在后台再开一个线程用于处理任务 ,不影响浏览器前台的js线程 简而言之: WebWorker 就是让原本单线程JS 实现多线程的操作 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。 = &gt; js引擎单线程 可以把一些计算复杂,庞大的运算逻辑通过worker去处理 这样就不会影响到前台页面的渲染 注意: 后台线程的任务中无法操作DOM , 只要是跟浏览器前台页面交互的东西都无法完成 没有使用webworker的代码（浏览器会先计算再进行渲染（单线程处理任务暂停页面渲染））&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个问候语!!!!!&lt;/h1&gt; &lt;script&gt; var sum = 0; for(var i=0;i&lt;10000000000;i++){ sum*=i; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用webworker把大量计算的js单独写一个js文件我们命名为task.js//taks.js 是需要在后台程序执行的一个脚本文件 this.onmessage = function (e) { sum+=e.data; console.log(e); } var sum = 1; for(var i=1;i&lt;1000000000;i++){ sum+=i; } function abc(){ console.log(&quot;执行了一个Abc方法 &quot;); } abc(); //向前台发送执行结果 postMessage(sum); 然后在页面中调用的时候需要实例化一个worker对象&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个问候语!!!!!&lt;/h1&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; //页面 (前台) 调用 H5 提供提供的worker = &gt; 相当于创建一个线程 var worker = new Worker(&quot;task.js&quot;); //在后台的线程中执行task.js 的代码 console.log(worker); /** * worker 中提供的 * -事件 * onerror : 后台线程执行错误触发的事件 * onmessage : 后台线程执行完可以调用一个方法给前台的js发送消息用来传值 * * -方法 * postMessage() 后台线程向前台发送消息 * terminate() 取消任务 , 如需终止 web worker，并释放浏览器/计算机资源，请使用 terminate() 方法 * * */ worker.onerror = function (e) { console.log(&quot;后台线程执行task任务失败!&quot;,e); } worker.onmessage = function (e) { console.log(&quot;后台线程发消息过来了!&quot;,e); document.getElementById(&quot;box&quot;).innerHTML=&quot;计算结果为:&quot;+e.data; } worker.postMessage(&quot;这是一个结果&quot;);//向task.js执行线程发送数据 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这样页面会先渲染出来，需要大量计算的js则会交给另一个线程处理","categories":[],"tags":[{"name":"Web Worker","slug":"Web-Worker","permalink":"/tags/Web-Worker/"}],"keywords":[]},{"title":"websocket基础","slug":"websocket通信基础","date":"2019-11-11T09:15:25.000Z","updated":"2020-06-21T13:10:21.316Z","comments":true,"path":"2019/11/11/websocket通信基础/","link":"","permalink":"/2019/11/11/websocket通信基础/","excerpt":"","text":"websocket基础websocket 通信协议特点:​ 1.不受浏览器同源策略限制​ 2.长连接协议​ 3.双向通信协议(只要通信连接了,那么就会一直保持,除非有一端 主动断开,那就断开连接) http / https / ftp 通信协议http协议特点 : (单向通信)​ 1.http协议是一种无状态协议。（每次访问服务器时，没有办法识别身份）​ 2.短连接协议（每次通信完毕就断开了）​ 3.http协议是一种单向通信协议（只能由客户的端主动向服务器发出请求，然后接受响应，服务器端不能主动给客户端发送消息）​ 4.每次发起HTTP请求时，都会将浏览器缓存的cookie发送给服务器端。​ 5.每次只能处理一个请求（两张图片，就是两个请求）​ 6.简单、快捷、高效 =====================================================================================电脑上的二维码图片 : 识别结果 = &gt; https://login.weixin.qq.com/l/IbliFrl0WQ== 打开手机微信扫描后就会先解析二维码 ,然后进行二维码地址的访问 =&gt; https://login.weixin.qq.com/l/IbliFrl0WQ== 因为手机上的微信是已经登录过的 ,所以通过手机微信浏览器访问这个地址的时候 ,服务器那边就知道是谁在访问 .此时还携带了一个与打开页面相同标识的参数 : IbliFrl0WQ== 所以此时 : 微信的登录服务器 会把 IbliFrl0WQ== 映射到 张三或者李四某一个账户 电脑版前端页面怎么知道有没有扫描,或者是哪微信个账号扫过码??? 传统的方式 : 由pc页面 使用ajax 请求微信服务器 ,会带上一个标识码 IbliFrl0WQ== ,去查询服务器上哪个账户与它曾经关联过, 如果查询到有关联的账户,就会把该账户的各种数据(微信的基本信息和联系人)返回,如果没有的话,还需要继续等待,稍后继续询问服务器是否有人扫码 ,直至有确认有人扫码登录了 (当然为了安全考虑,微信会设置标识码的存活时间5分钟左右,如果超时就会换一个) ========================================================================生活例子: 小明本来想去买套房, 今天去售楼处问了一下 ,本来想买一套120平 , 但是目前剩余只有80平 或者200平 , 但是售楼处的小姐跟他说,可能会有后期(没有明确时间)有增加房源 ,然后小明就会回家 … 最终有没有房源,只有售楼处才清楚, 如果真要去解解决这个问题,应该让售楼处 有房源的时候主动通知小明 (比较好的方案) 过两天 再去售楼处问问有没有房 , 没有 再过两天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 ======================================================================比如网页的数据需要实时更新 怎么实现? 1.使用ajax ,设置每隔1s请求一次 = &gt; 轮询 请求频率高 ,性能低,极度浪费服务器的资源 ,请求的时间间隔不一 2.websocket 协议: 只要连接上了 ,服务器数据有更新,自动推送到客户端 节约大量的http请求资源 ,效率高, 实时性强 websocket协议使用&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; /* Websocket 构造函数 ,提供ws协议的使用 , 实现双向通信(全双工通信) WebSocket协议的目标是在一个独立的持久连接上提供全双工双向通信。客户端和服务器可以向对方主动发送和接受数据。在JS中创建WebSocket后，会有一个HTTP请求发向浏览器以发起请求。在取得服务器响应后，建立的连接会使用HTTP升级将HTTP协议转换为WebSocket协议。也就是说，使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。 WebSocket是应用层协议，是TCP/IP协议的子集，通过HTTP/1.1协议的101状态码进行握手。也就是说，WebSocket协议的建立需要先借助HTTP协议， 在服务器返回101状态码之后，就可以进行websocket全双工双向通信了，就没有HTTP协议什么事情了。 需要提前准备一个ws协议 的后台 Websocket 对象 属性: readyState : 当前连接状态 = &gt; CLOSED: 3 CLOSING: 2 CONNECTING: 0 OPEN: 1 url : 连接地址 protocol :协议 事件: onclose: 关闭连接事件 onerror: 连接错误事件 onmessage: 消息事件 (后端主动发送消息过来触发的事件) onopen: 连接成功 方法: close() 关闭连接 send() 发送消息 */ var ws = new WebSocket(&quot;ws://172.16.4.1:8000&quot;); //连接事件 - 成功 ws.onopen = function(){ console.log(&quot;已经建立连接...&quot;); }; //连接失败事件 ws.onerror = function(){ console.log(&quot;连接建立失败...&quot;); }; //消息事件 ws.onmessage = function (e) { console.log(&quot;后端发消息来了...&quot;,e.data); } //关闭连接事件 ws.onclose = function () { console.log(&quot;关闭连接事件!&quot;); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面用服务器搭建了一个群聊（可以使用接口来获取信息也可发送信息）地址已经封装在js中了 ,后台会返回一个js脚本只需要引入脚本即可 ws : http://m.lby.link:8888 js地址: http://m.lby.link:8888/socket.io/socket.io.js 可以直接使用已经封装好的js脚本库 io对象 &lt;script src=&quot;http://m.lby.link:8888/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; ------------------------------消息发送方----------------------------------------- var txt = document.getElementById(&quot;txt&quot;); var socket = io.connect(&#39;http://m.lby.link:8888&#39;);//获取监听 var send = function(){ //emit 发射 ,其实就是触发服务端监听的client事件 var data = { username:&quot;张三&quot;, msg:txt.value } socket.emit(&#39;client&#39;,data);//发送给服务端数据 } -----------------------------消息接收方------------------------------------- var container = document.querySelector(&quot;#container&quot;); var socket = io.connect(&#39;http://m.lby.link:8888&#39;);//获取监听 socket.on(&#39;server&#39;,function(data){//监听服务端发送过来的事件 container.innerHTML+=&quot;&lt;br/&gt;&quot;+data.username + &quot;:&quot; + data.msg; }); ---------------------------统一发送的数据格式规范------------------------------ 发送的数据格式 : json 对象 { username:&quot;发送者姓名&quot;, msg:&quot;发送的消息&quot;, sex:&quot;男&quot;, timestamp:new Date().getTime() } 在线智能机器人对话&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;在线智能对话&lt;/title&gt; &lt;style&gt; body{ font-family:&quot;微软雅黑&quot;; font-size: 12px; } .container{ position: relative; width: 60%; margin: 0 auto; padding: 15px 0; border: 1px solid #ccc; border-radius: 5px; overflow: hidden; height: 90vh; } #chat-box{ height: 90%; overflow: auto; padding-bottom:20px; } .chat{ position: relative; padding: 15px; width: 100%; max-width: 60%; margin: 5px 0; border-radius: 5px; } .chat.other{ float: left; background:#2aabd2; } .chat.self{ float: right; background: #48ca09; } .chat.system{ width: auto; max-width: 80%; color: #999; margin: 0px auto; background: none; text-align: center; } .chat.system span{ background: #f1f1f1; /*display: inline-block;*/ padding: 4px 8px; border-radius: 5px; } .chat .date{ position: absolute; top: 3px; left:0px; color: #fff; text-align: left; padding-left: 20px; font-size: 12px; } .chat .info{ padding-top: 10px; color: #333; } .msg-box:after{ content: &quot;&quot;; display: block; clear: both; } #send-box{ position: absolute; bottom: 0; padding: 5px 10px; width: 100%; background: #2aabd2; } #send-box input{ padding: 5px 8px; border: 1px solid #ccc; width: 50%; } #send-box button{ border: 0; padding: 6px 10px; cursor: pointer; } #send-box button:hover{ background: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;chat-box&quot;&gt;&lt;/div&gt; &lt;div id=&quot;send-box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;msg&quot;&gt; &lt;button class=&quot;send&quot;&gt;发送&lt;/button&gt; &lt;button class=&quot;close&quot;&gt;断开&lt;/button&gt; &lt;button class=&quot;reconnect&quot;&gt;重新连接&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/moment.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /** * 每次发完消息, 滚动最后一条记录 : 滚动距离 = 最后一条消息 距离聊天窗口容器的顶部距离(包括滚动距离) * */ var ws = null;// ws 实例对象 //定义一个连接方法 function connect(){ ws = new WebSocket(&quot;ws://172.16.4.1:8000&quot;); //绑定一些事件 ws.onopen = function () { writeSystemMessage(&quot;已经与服务器建立连接...&quot;); } ws.onclose = function () { writeSystemMessage(&quot;您已经与服务器断开连接...&quot;); } ws.onmessage = function (e) { writeChatMessage(e.data,&quot;other&quot;); } ws.onerror = function () { writeSystemMessage(&quot;网络异常,请重新连接...&quot;); } } //定义一个生成系统消息的方法 function writeSystemMessage(msg){ var str = $(&quot;&lt;div class=&#39;msg-box&#39;&gt;&lt;div class=&#39;chat system&#39;&gt;&lt;span&gt;&quot;+moment(new Date()).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)+&quot; &quot; + msg+&quot;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&quot;); $(&quot;#chat-box&quot;).append(str); scrollLastMessage(); // console.log(msg); } //定义一个写入聊天信息的方法 function writeChatMessage(msg,role){ // msg 消息 , role 发送消息角色 var str = $(&quot;&lt;div class=&#39;msg-box&#39;&gt;&lt;div class=&#39;chat &quot;+role+&quot;&#39;&gt;&lt;div class=&#39;date&#39;&gt;&quot;+moment(new Date()).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)+&quot;&lt;/div&gt;&lt;div class=&#39;info&#39;&gt;&quot;+msg+&quot;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&quot;); $(&quot;#chat-box&quot;).append(str); scrollLastMessage(); } //定义一个滚动到最后一条消息位置 function scrollLastMessage(){ //先获取最后一条消息距离网页顶部的距离 var topH = $(&quot;.msg-box:last&quot;)[0].offsetTop; //给消息盒子设置滚动距离 $(&quot;#chat-box&quot;).scrollTop(topH); } //进入聊天页面 ,自动连接 connect(); //绑定发送消息事件 $(&quot;.send&quot;).click(function(){ if(ws.readyState==1){ var msg = $(&quot;#msg&quot;).val(); writeChatMessage(msg,&quot;self&quot;); //向服务器发送消息 ws.send(msg); $(&quot;#msg&quot;).val(&quot;&quot;); }else{ writeSystemMessage(&quot;网络异常,请尝试重新连接...&quot;) } }) //绑定断开连接 $(&quot;.close&quot;).click(function(){ if(ws.readyState!=3){ ws.close();//关闭连接 } }) //重新连接 $(&quot;.reconnect&quot;).click(connect); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"websocket","slug":"websocket","permalink":"/tags/websocket/"}],"keywords":[]},{"title":"OOP思想(面向对象思想)","slug":"OOP思想-面向对象思想","date":"2019-10-18T06:38:53.000Z","updated":"2020-06-21T13:10:21.253Z","comments":true,"path":"2019/10/18/OOP思想-面向对象思想/","link":"","permalink":"/2019/10/18/OOP思想-面向对象思想/","excerpt":"","text":"OOP思想应该怎样来理解？ https://blog.csdn.net/qq157962718/article/details/50990154 https://www.cnblogs.com/xiaosongluffy/p/5072501.html https://blog.csdn.net/sinat_37212928/article/details/72874598 它强调对象的“抽象”、“封装”、“继承”、“多态”。 OOP思想浅谈 收藏07年11月27号在校内举办了第一次技术讲座，主题是Java now and future.和以往的同主题的讲座不同，我在讲座里面着重讲了一下我对OOP思想的理解并对比了Java和C++的区别，这也是很多编程爱好者所津津乐道的话题，至于大家喜欢哪种编程语言我个人觉得主要决定于自己的性格，当初喜欢Java也是因为其跨平台的特点，和外向兴趣广泛的我一样，能让生活充满更多的乐趣和颜色。 ​ 下面浅谈下我对OOP思想的理解，OOP思想中很重要的有五点，类，对象，还有面向对象的三大特征：继承，多态和封装。 ​ 类：对现实世界事物的抽象表示，包括事物的状态信息（成员变量）和行为信息（成员方法）。我们要让我们的计算机程序设计更有意思，也更有逻辑性，则我们的程序中对事物的描叙就必须符合真实情况，同时符合人类的思维习惯。因此，我们如果在计算中要描叙人这个事物，也是一类事物，我们就必须把该事物的所有特点包含进来，用成员变量描叙人的基本属性，如：身高，体重，年龄，性别等。这样就可以描叙一个“静态”的人了，所谓静态的意思也就是该人并不参与任何社会活动，没有任何行为。但是这样并不符合现实意义，那样我们必须为人添上行为，让他参加社会活动有自己的行为。所以我们需要用成员方法来描叙人的活动，如：吃饭，洗澡，睡觉等。 ​ 对象：对抽象事物的具体表示，使其具有自身的特点。类好比一个大的集合，里面的元素都有共同的特点，但是比较每个元素又可以发现每个有其自身的特点，对象就是这样，它是一个类的具体化，也是实例化，类是泛指，而对象是特指。虽然人都有身高，体重，年龄，同时有行为有吃饭，洗澡，睡觉等，但是当具体到某个人的时候就会有不同，例如：老人和小孩的年龄就有不同，所以，从类到对象是我们把现实事物进行计算机描叙的过程，同时也是一个从抽象到具体的过程，这很符合我们的真实思维逻辑。 ​ 下面浅谈一下面向对象的三大特征的基本思想。 ​ 多态：用一种解决方案来解决对一类问题，对于不同的事物解决途径和结果不同。在C++中实现多态性有三种方法，分别是：虚函数，函数重载和运算符重载。这三种方法大家都可以看到我们解决问题的初衷是一样的，都是利用同名函数，同名的运算符号，这抽象出来也就是解决问题的方法，但是对于不同的事物的反应却是不同的，例如：当用一个getPadNumber()方法来得到普通自行车和双人自行车的坐垫数量的时候，返回的结果是一个和两个，这就是具体的事物返回的结果不同。 ​ 继承：让抽象出来的事物具有本应该具有的联系。我们能用类来描叙一个抽象的事物，同时能用对象来描叙具体的事物，但是这些事物都是独立的，彼此之间没有应该有的联系，这样的孤立设计并不符合现实逻辑，让事物之间的联系得到描叙，我们就需要继承，例如：发明自行车的人并不是一开始就发明了多人自行车，这些都是从双轮自行车演变和发展而来，但是他们都有共同的特点，有轮子，有车架子，等等。让我们用继承的关系把这两个现实的抽象联系起来，这样我们就能设计出不孤立的类，而是和其他类有联系的类。 ​ 封装：让抽象的事物保护自身的状态，防止非其他事物对其进行错误的状态改变操作。我们抽象完一个事物后，可能在特定的条件下，其本身的状态需要改变，但是这个改变并允许其他的事物来进行，这样的改变只允许这个事物认同的操作域来进行，可以是该事物本身，也可以是它信任的其他事物。这样我们就能对我们抽象完的每个事物进行自身数据的保护。 以下有几个案例创建对象-字面量创建&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //1. 使用字面量方式创建对象 var obj = { name:&quot;张三&quot;, run:function () { console.log(&#39;我能跑&#39;); } } obj.run(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 创建对象-使用new Object&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //回顾数组 , 日期 , 正则 , 数字 , 字符串对象, 布尔对象 ... // var arr = new Array(); // var date = new Date(); // var reg = new RegExp(); //不足: 创建使用单一 ,过程繁琐 ,不能很好支持创建多个对象 var obj = new Object(); //创建一个对象 , 空对象 obj.name = &quot;张三&quot;; obj[&#39;run&#39;] = function(){ console.log(&#39;我能跑!&#39;); } console.log(obj); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 创建对象-工厂模式&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //3.工厂模式 = &gt; 批量大量操作 : 其实就是把创建对象的过程封装成一个方法 //工厂模式属于23中设计模式的一种 详情见:http://c.biancheng.net/design_pattern/ //可以解决批量声明对象的繁琐过程和重复代码问题 //但是 使用工厂模式批量创建的对象都是Object , 无法 像js中内置的Array , Date , RegExp ... 一样 ,容易辨别什么对象 //检测数据类型 : typeof = &gt; number , string , null , undefined , boolean object //检测对象的类型 instanceof 检测对象是由哪个类(模具)创建出来的 var arr = new Array(); console.log(arr instanceof Array); // = &gt; true , 可以理解为arr是不是由Array 这个模子刻出来的 function createObj(index,len){ var obj = new Object(); obj.index = index; obj.len = len; obj.autoplay = function () { console.log(&#39;这是一个自动播放的函数!&#39;); } return obj; } //批量创建对象 var slide1 = createObj(1,5); var slide2 = createObj(3,12); var slide3 = createObj(4,9); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 面向对象编程思想&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; /* 面向过程 : 就是把需要解决问题的事务分解成一个个的步骤 , 然后按所需要的步骤一个个执行(调用方法) 面向过程一样可以解决实际的问题, 但是这种思想,方式不利于项目的维护, 变更 ,扩展 不能很好实现代码的灵活复用或者业务解耦 ,容易造成代码冗余 面向对象 : 把构成问题的事务,分解成各个对象 ,每个对象只负责各自部分(实现代码业务解耦) 使用生活例子理解: 面向过程 : 像刀耕火种的时代, 从耕地 , 农活 , 收割 , 打谷 ,做饭 , 衣服 ,纺织 ... (一个人全部流程实现) 面向对象 : 现代社会 , 把日常生活工作 分配到不同岗位或行业领域,每个领域有各自的职责任务 (把任务分解,各自独立, 互不影响) */ &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 面向对象-混合模式(原型+构造模式)&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; /** * 无论是单纯的构造函数(浪费一些内存) , 还是单纯的原型(参数无法自定义),都只能解决某一些问题,还不是最终完美的方案 * 理想方案: 该独立的独立 ,该共享的就共享 ,实现功能和内存的优化 * 混合模式 = 构造函数 + 原型 * * 一般做法: 属性通过构造函数添加 (不同) , 方法就通过原型添加 (一样) */ function Cat (name,type){ this.name = name; this.type = type; } Cat.prototype.catchMouse = function () { console.log(&quot;我能抓老鼠!&quot;); } var cat1 = new Cat(&quot;小花&quot;,&quot;波斯猫&quot;); var cat2 = new Cat(&quot;小黑&quot;,&quot;加菲猫&quot;); console.log( cat1.catchMouse === cat2.catchMouse); // true 说明内存地址一样 //其实在js内置的构造函数中 ,也是把一些方法添加到对应的原型上的 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 原型的常规妙用&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //其实在js内置的构造函数中 ,也是把一些方法添加到对应的原型上的 (一般不会去修改原来的方法, 如果需要改善 会直接新增方法) Array.prototype.push2 = function () { console.log(this) ;// this = &gt; arr console.log(arguments); for (var i =0;i&lt;arguments.length;i++){ this.push(arguments[i]*arguments[i]); } } var arr = []; // = &gt; 等价于 new Array() 就是一个构造函数的实例化过程 // arr.push(1,2,3); arr.push2(1,2,3); // = &gt; 预期: [1 ,4, 9] console.log(arr); var arr2 = []; arr2.push2() // 可以把一些常用的方法 ,添加到对应构造函数的原型上,从而实现方便的调用 // Math 数学对象, 不是一个函数 ,更不是一个构造函数,所有没有原型,无法通过原型修改 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"OOP面向对象思想","slug":"OOP面向对象思想","permalink":"/tags/OOP面向对象思想/"}],"keywords":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2021-09-17T09:19:15.685Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura 主题 English document 基于 WordPress 主题Sakura修改成 Hexo 的主题。 demo 预览 正在开发中…… 交流群若你是使用者，加群 QQ: 801511924 若你是创作者，加群 QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine 评论 fancy-box 相册 pjax 支持，音乐不间断 aplayer 音乐播放器 多级导航菜单（按现在大部分 hexo 主题来说，这也算是个特性了） 赞赏作者如果喜欢 hexo-theme-sakura 主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理 233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些 source 的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config 配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用 hexo b 发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/QuerySelector/QuerySelector.git,backup 主题目录下的_config 配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: QuerySelector # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.QuerySelector.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://i2.hdslb.com/bfs/face/9f83173231a3c0dbbf7e8fd4da7b81044fdda910.jpg@120w_120h_1c_1s.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: { path: /categories/技术/, fa: fa-code }, 生活: { path: /categories/生活/, fa: fa-file-text-o }, 资源: { path: /categories/资源/, fa: fa-cloud-download }, 随想: { path: /categories/随想/, fa: fa-commenting-o }, 转载: { path: /categories/转载/, fa: fa-book }, }, } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: { path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: { path: /bangumi/, fa: fa-film faa-vertical }, 歌单: { path: /music/, fa: fa-headphones }, 图集: { path: /tags/图集/, fa: fa-photo }, }, } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench, submenus: { 我？: { path: /about/, fa: fa-meetup }, 主题: { path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: { path: /lab/, fa: fa-cogs }, }, } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - { url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png, } - { url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg, } - { url: /, title: QuerySelector的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg, } # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: { url: http://github.com/honjun, img: /img/social/github.png } sina: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png } wangyiyun: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png } zhihu: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png } email: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg } wechat: { url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png } # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: { url: http://github.com/honjun, fa: fa-github, color: 333 } weibo: { url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39 } qq: { url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe, } # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/QuerySelector@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/QuerySelector@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml 里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把 404 图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以 issue 或群里提出来），现在是没设置的话会使用那种倒立小狗 404 哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于 source 下的 comment 下，打开 index.md 如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件 hexo-tag-bili 和 hexo-tag-fancybox_img。其中 hexo-tag-bili 用来在文章或单页面中插入 B 站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img 用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"js中的跨域及其解决的办法","slug":"js中的跨域问题解决","date":"2018-12-05T10:40:25.000Z","updated":"2020-06-21T13:10:21.274Z","comments":true,"path":"2018/12/05/js中的跨域问题解决/","link":"","permalink":"/2018/12/05/js中的跨域问题解决/","excerpt":"","text":"js中的跨域及其解决的办法一、什么是跨域？在了解跨域之前，首先要知道什么是同源策略（same-origin policy）。简单来讲同源策略就是浏览器为了保证用户信息的安全，防止恶意的网站窃取数据，禁止不同域之间的JS进行交互。对于浏览器而言只要域名、协议、端口其中一个不同就会引发同源策略，从而限制他们之间如下的交互行为： 1.Cookie、LocalStorage和IndexDB无法读取； 2.DOM无法获得； 3.AJAX请求不能发送。 跨域的严格一点的定义是：只要协议，域名，端口有任何一个的不同，就被当作是跨域。 如下表所示： URL 说明 是否允许通信 http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 特别注意两点： 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的， 第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 “URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。 二、为什么浏览器要限制跨域访问呢？原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题： 1.用户访问www.mybank.com，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器； 2.用户突然想起件事，并迷迷糊糊的访问了一个邪恶的网站www.xiee.com； 3.这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对www.mybank.com的操作； 4.如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。 三、为什么要跨域？既然有安全问题，那为什么又要跨域呢？ 有时公司内部有多个不同的子域，比如一个是location.company.com ,而应用是放在app.company.com , 这时想从 app.company.com去访问 location.company.com 的资源就属于跨域。 四、解决跨域问题的方法：1.跨域资源共享（CORS）CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！ 如下所示： //指定允许其他域名访问 &#39;Access-Control-Allow-Origin:*&#39;//或指定域 //响应类型 &#39;Access-Control-Allow-Methods:GET,POST&#39; //响应头设置 &#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39; 2.通过jsonp跨域JSONP是JSON with Padding（填充式json）的简写，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如： callback({&quot;name&quot;,&quot;trigkit4&quot;}); JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。 JSONP的原理：通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。（即用JavaScript动态加载一个script文件，同时定义一个callback函数给script执行而已。） 在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是http://example.com/data.php，那么a.html中的代码就可以这样： function dosomething(jsondata){ //处理获得的json数据 } js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 &lt;?php callback = _GET[&#39;callback&#39;];//得到回调函数名 data = array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);//要返回的数据 echo callback.&#39;(&#39;.json_encode($data).&#39;)&#39;;//输出 ?&gt; 最终，输出结果为：dosomething([‘a’,’b’,’c’]); 如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。 $.getJSON(‘http://example.com/data.php?callback=?,function(jsondata)&#39;){ //处理获得的json数据 }); JSONP的优缺点：JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 CORS和JSONP对比：CORS与JSONP相比，无疑更为先进、方便和可靠。 （1）JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求； （2）使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得说句，比起JSONP有更好的错误处理； （3）JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS； 3.通过修改document.domain来跨子域上面的jsonp是来解决ajax跨域请求的，那么如果是需要处理 Cookie 和 iframe 该怎么办呢？这时候就可以通过修改document.domain来跨子域。两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie或者处理iframe。比如A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 document.domain = &#39;example.com&#39;; //现在，A网页通过脚本设置一个 Cookie。 document.cookie = &quot;test1=hello&quot;; //B网页就可以读到这个 Cookie。 var allCookie = document.cookie; 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。 Set-Cookie: key=value; domain=.example.com; path=/ //这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 不同的iframe 之间（父子或同辈），是能够获取到彼此的window对象的，但是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。首先说明一下同域之间的iframe是可以操作的。比如http://127.0.0.1/JSONP/a.html里面嵌入一个iframe指向http://127.0.0.1/myPHP/b.html。那么在a.html里面是可以操作iframe里面的DOM的。 var iframe = document.querySelector(“iframe”);iframe.onload = function(){ var win = iframe.contentWindow; var doc = win.document; var ele = doc.querySelector(“.text1”); var text = ele.innerHTML=”123456”;}如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。如果两个窗口一级域名相同，只是二级域名不同，那么document.domain属性，就可以规避同源政策，拿到DOM。 4.使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。比如：有一个页面a.html,它里面有这样的代码： window.name = &quot;我是a页面设置的&quot;; setTimeout(function(){ window.location = &quot;http://127.0.0.1/JSONP/b.html&quot;; },1000) b.html页面的代码：console.log(window.name); ​ a.html页面载入后1秒，跳转到了b.html页面，结果b页面打印出了：我是a页面设置的 可以看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。利用window.name可以对同域或者不同域的之间的js进行交互。那么在a.html页面中，我们怎么把b.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变window.location来载入b.html页面，因为我们想要即使a.html页面不跳转也能得到b.html里的数据。答案就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取b.html的数据，然后a.html再去得到iframe获取到的数据。 5.使用HTML5的window.postMessage方法跨域上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。举例来说，父窗口http://a.com向子窗口http://b.com发消息，调用postMessage方法就可以了。a页面： document.getElementById(‘frame1’).onload = function(){ var win = document.getElementById(‘frame1’).contentWindow; win.postMessage(“我是来自a页面的”,”http://127.0.0.1/JSONP/b.html&quot;)} b页面通过监听message事件可以接受到来自a页面的消息。 window.onmessage = function(e){ e = e || event; console.log(e.data);//我是来自a页面的 } 子窗口向父窗口发送消息的写法类似。 window.opener.postMessage(‘我是来自b页面的’, ‘http://a.com&#39;);//父窗口和子窗口都可以通过message事件，监听对方的消息。通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。父窗口发送消息代码： var win = document.getElementsByTagName(‘iframe’)[0].contentWindow;var obj = { name: ‘Jack’ };// 存入对象win.postMessage(JSON.stringify({key: ‘storage’, method: ‘set’, data: obj}), ‘http://b.com&#39;);// 读取对象win.postMessage(JSON.stringify({key: ‘storage’, method: “get”}), “*”);window.onmessage = function(e) { if (e.origin != ‘http://a.com&#39;) return; // “Jack” console.log(JSON.parse(e.data).name);};子窗口接收消息的代码： window.onmessage = function(e) { if (e.origin !== ‘http://bbb.com&#39;) return; var payload = JSON.parse(e.data); switch (payload.method) { case ‘set’: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case ‘get’: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, ‘http://aaa.com&#39;); break; case ‘remove’: localStorage.removeItem(payload.key); break; }}; 6.通过WebSocket进行跨域web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在js创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 var socket = new WebSockt(&#39;ws://www.baidu.com&#39;);//http-&gt;ws; https-&gt;wss socket.send(&#39;hello WebSockt&#39;); socket.onmessage = function(event){ var data = event.data; } 7.图像ping（单向）什么是图像ping：图像ping是与服务器进行简单、单向的跨域通信的一种方式，请求的数据是通过查询字符串的形式发送的，而相应可以是任意内容，但通常是像素图或204相应（No Content）。 图像ping有两个主要缺点：首先就是只能发送get请求，其次就是无法访问服务器的响应文本。 使用方法：var img = new Image(); img.onload = img.onerror = function(){ alert(&quot;done!&quot;); }; img.src = &quot;https://raw.githubusercontent.com/zhangmengxue/Todo-List/master/me.jpg&quot;; document.body.insertBefore(img,document.body.firstChild); 然后页面上就可以显示我放在我的github上某个地方的照片啦。 与类似的可以跨域内嵌资源的还有: (1)标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。上面jsonp也用到了呢。 (2) 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。 (3) 和 嵌入多媒体资源。 (4), 和 的插件。 (5)@font-face引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 (6) 和 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 8.使用片段识别符来进行跨域片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#flag的#flag。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。在父窗口写入： document.getElementById(&#39;frame&#39;).onload = function(){ var src = &quot;http://127.0.0.1/JSONP/b.html&quot; + &#39;#&#39; + &quot;data&quot;; this.src = src; } 子窗口通过监听hashchange事件得到通知。window.onload = function(){ console.log(&quot;b.html加载完成&quot;) window.onhashchange = function(){ var message = window.location.hash; console.log(message)//#data }; } 同样的，子窗口也可以改变父窗口的片段标识符。parent.location.href= target + &quot;#&quot; + hash;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[]},{"title":"Photoshop软件使用基础","slug":"Photoshop软件使用基础","date":"2018-10-22T02:40:55.000Z","updated":"2020-06-21T13:10:21.256Z","comments":true,"path":"2018/10/22/Photoshop软件使用基础/","link":"","permalink":"/2018/10/22/Photoshop软件使用基础/","excerpt":"","text":"Photoshop软件使用基础 Photoshop是一款非常强大的图形图像处理软件. 图片格式 jpeg(.jpg) ​ 优点:图片支持高压缩(文件可以进行高比例的压缩),真色彩(图像色彩丰富,细致) ​ 缺点: 不能制作动图 , 不能制作透明图片 ​ 使用场景:没有特殊要求(背景透明,动态图片)情况下,例如: 人物照片\\风景\\新闻图片等 png ​ 优点:可以制作一些透明背景/半透明背景的图片 ,图片质量高,清晰度高 ​ 缺点:图片不支持压缩,文件相对而言比较大 ​ 使用场景: 主要使用在一些背景需要透明化的图片场景,例如 :网站logo \\ 各种小图标 gif ​ 优点:可以制作动画 ,可以制作一些全透明图片 ,支持压缩 ​ 缺点:图像的色彩有限(图像显示效果不好) ​ 使用场景: 动态图片 色彩原理:​ 光的组成: 三原色 ​ 一、RGB色彩模式: 用于电子显示屏设备(手机\\电脑\\平板\\投影仪等电子设备) ​ 红(Red): 0 - 255 ​ 绿(Green):0 - 255 ​ 蓝(Blue):0 - 255 ​ 色域: 在RGB色彩模式能表示的颜色 = 256 256 256 约等于 1600万 , 2^24 ,所以也称之为 “24色” ​ 表示方式(后期网页中会使用到): ###### RGB方式 ​ rgb(255,255,255) 白色 ​ rgb(0,0,0) 黑色 ###### 十六进制: (0-F 表示 0-15) ​ R G B 00 00 00 =&gt; #000000 黑色 ​ 255 255 255 =&gt; #ffffff 白色 ​ 255 0 0 =&gt;#ff 00 00 红色 ​ 二、CMYK:用于打印印刷 (四种打印机的墨盒色) ​ C:青色 ​ M:品红 ​ Y:黄色 ​ K:黑色 (PS)图像: 图片由像素点构成 也称之为 “位图” , 图像在放大诺干倍之后会看见像素点, 图像也会随之模糊 (AI)图形:点和线构成 ,也称之为 “矢量图” ,无限放大依然清晰 ,不失真. 分辨率 :在单位英寸中所包含的像素点的数量 : 如果只用于电子屏展示 72 / 如果需要打印 设置为 300 选区(ps的核心之一) : 选择需要执行某项操作的区域 (一般呈现为虚线) , 如果没有选中,则默认为全选.Ps快捷键: 填充前景色: alt + delete 填充背景色: ctrl + delete 取消选择: ctrl + D 撤销上一步: ctrl + alt + Z 放大/缩小视图: ctrl + +/- (按住alt 键 + 滚动鼠标滚轮) 自由变换: ctrl + T 重复上一次并且复制 :ctrl + alt + shift + T 合并图层: ctrl + E 复制图层: ctrl + J 反相(黑白颠倒):ctrl + I 反向选择:ctrl + shift + I 盖印可见图层:ctrl + shift + alt +E 画布: 画布舞台大小(白纸的大小) 图像: 只改变当前图像的大小 ,画布舞台还是不变的 动画: ​ FPS : FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频每秒的绘制画面数。 ​ 蒙版: 用蒙版图层控制图层的显示与隐藏 : ​ 白色 = &gt; 显示 ​ 黑色 = &gt; 不显示 ​ 灰色 =&gt; 半透明 项目文件目录: ​ images (存放图片) ​ css (css样式文件) ​ js (js脚本文件) 文件目录及文件命名规范: ​ 1.文件名不能使用中文 ​ 2.不能使用特殊符号 ​ 3.一般使用字母 + 数字 \\ 或者 \\ 下划线 \\ @ ​ 4.文件名要做到见名识义(使用英文单词 \\ 中文拼音 ) 百度翻译","categories":[],"tags":[{"name":"photoshop","slug":"photoshop","permalink":"/tags/photoshop/"}],"keywords":[]}]}